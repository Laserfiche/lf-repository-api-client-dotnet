//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

using Laserfiche.Api.Client;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace Laserfiche.Repository.Api.Client
{
    using System = global::System;

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IAttributesClient
    {

        /// <summary>
        /// Returns the attribute key value pairs associated with the authenticated user.
        /// </summary>
        /// <remarks>
        /// - Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group.<br/>
        /// - Attribute keys can be used with subsequent calls to get specific attribute values.<br/>
        /// - Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.<br/>
        /// - Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="everyone">Indicates if attributes associated with the "Everyone" group or the currently authenticated user is returned. The default value is false.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of attributes associated with the authenticated user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<AttributeCollectionResponse> ListAttributesAsync(string repositoryId, bool? everyone = null, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns an attribute object associated with the authenticated user.
        /// </summary>
        /// <remarks>
        /// - Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group.<br/>
        /// - Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="attributeKey">The requested attribute key.</param>
        /// <param name="everyone">Indicates if attributes associated with the "Everyone" group or the currently authenticated user is returned. The default value is false.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single attribute associated with the authenticated user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Attribute> GetAttributeAsync(string repositoryId, string attributeKey, bool? everyone = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AttributesClient : BaseClient, IAttributesClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public AttributesClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns the attribute key value pairs associated with the authenticated user.
        /// </summary>
        /// <remarks>
        /// - Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group.<br/>
        /// - Attribute keys can be used with subsequent calls to get specific attribute values.<br/>
        /// - Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.<br/>
        /// - Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="everyone">Indicates if attributes associated with the "Everyone" group or the currently authenticated user is returned. The default value is false.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of attributes associated with the authenticated user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<AttributeCollectionResponse> ListAttributesAsync(string repositoryId, bool? everyone = null, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Attributes?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (everyone != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("everyone") + "=").Append(Uri.EscapeDataString(ConvertToString(everyone, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListAttributesSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<AttributeCollectionResponse> ListAttributesSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<AttributeCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns an attribute object associated with the authenticated user.
        /// </summary>
        /// <remarks>
        /// - Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group.<br/>
        /// - Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="attributeKey">The requested attribute key.</param>
        /// <param name="everyone">Indicates if attributes associated with the "Everyone" group or the currently authenticated user is returned. The default value is false.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single attribute associated with the authenticated user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Attribute> GetAttributeAsync(string repositoryId, string attributeKey, bool? everyone = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (attributeKey == null)
                throw new ArgumentNullException("attributeKey");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Attributes/{attributeKey}?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{attributeKey}", Uri.EscapeDataString(ConvertToString(attributeKey, CultureInfo.InvariantCulture)));
            if (everyone != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("everyone") + "=").Append(Uri.EscapeDataString(ConvertToString(everyone, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await GetAttributeSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Attribute> GetAttributeSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Attribute>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IAuditReasonsClient
    {

        /// <summary>
        /// Returns the audit reasons associated with the authenticated user.
        /// </summary>
        /// <remarks>
        /// - Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included.<br/>
        /// - Only includes audit reasons associated with available API functionalities, like delete entry and export document.<br/>
        /// - If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of audit reasons.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<AuditReasonCollectionResponse> ListAuditReasonsAsync(string repositoryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuditReasonsClient : BaseClient, IAuditReasonsClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public AuditReasonsClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns the audit reasons associated with the authenticated user.
        /// </summary>
        /// <remarks>
        /// - Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included.<br/>
        /// - Only includes audit reasons associated with available API functionalities, like delete entry and export document.<br/>
        /// - If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of audit reasons.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<AuditReasonCollectionResponse> ListAuditReasonsAsync(string repositoryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/AuditReasons?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListAuditReasonsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<AuditReasonCollectionResponse> ListAuditReasonsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<AuditReasonCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IFieldDefinitionsClient
    {

        /// <summary>
        /// Returns a single field definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single field definition associated with the specified ID. <br/>
        /// - Useful when a route provides a minimal amount of details and more information about the specific field definition is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="fieldId">The requested field definition ID.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single field definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<FieldDefinition> GetFieldDefinitionAsync(string repositoryId, int fieldId, string culture = null, string select = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the paged listing of the field definitions available in a repository.
        /// </summary>
        /// <remarks>
        /// - Returns a paged listing of field definitions available in the specified repository.<br/>
        /// - Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of field definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<FieldDefinitionCollectionResponse> ListFieldDefinitionsAsync(string repositoryId, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FieldDefinitionsClient : BaseClient, IFieldDefinitionsClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public FieldDefinitionsClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns a single field definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single field definition associated with the specified ID. <br/>
        /// - Useful when a route provides a minimal amount of details and more information about the specific field definition is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="fieldId">The requested field definition ID.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single field definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<FieldDefinition> GetFieldDefinitionAsync(string repositoryId, int fieldId, string culture = null, string select = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (fieldId == null)
                throw new ArgumentNullException("fieldId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/FieldDefinitions/{fieldId}?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{fieldId}", Uri.EscapeDataString(ConvertToString(fieldId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await GetFieldDefinitionSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<FieldDefinition> GetFieldDefinitionSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<FieldDefinition>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the paged listing of the field definitions available in a repository.
        /// </summary>
        /// <remarks>
        /// - Returns a paged listing of field definitions available in the specified repository.<br/>
        /// - Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of field definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<FieldDefinitionCollectionResponse> ListFieldDefinitionsAsync(string repositoryId, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/FieldDefinitions?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListFieldDefinitionsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<FieldDefinitionCollectionResponse> ListFieldDefinitionsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<FieldDefinitionCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ILinkDefinitionsClient
    {

        /// <summary>
        /// Returns the link definitions associated with a repository.
        /// </summary>
        /// <remarks>
        /// - Returns the link definitions in the repository.<br/>
        /// - Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of link definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<LinkDefinitionCollectionResponse> ListLinkDefinitionsAsync(string repositoryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns a single link definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single link definition associated with the specified ID.<br/>
        /// - Provide a link definition ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="linkDefinitionId">The requested link definition ID.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single link definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<LinkDefinition> GetLinkDefinitionAsync(string repositoryId, int linkDefinitionId, string select = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LinkDefinitionsClient : BaseClient, ILinkDefinitionsClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public LinkDefinitionsClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns the link definitions associated with a repository.
        /// </summary>
        /// <remarks>
        /// - Returns the link definitions in the repository.<br/>
        /// - Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of link definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<LinkDefinitionCollectionResponse> ListLinkDefinitionsAsync(string repositoryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/LinkDefinitions?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListLinkDefinitionsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<LinkDefinitionCollectionResponse> ListLinkDefinitionsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<LinkDefinitionCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns a single link definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single link definition associated with the specified ID.<br/>
        /// - Provide a link definition ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="linkDefinitionId">The requested link definition ID.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single link definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<LinkDefinition> GetLinkDefinitionAsync(string repositoryId, int linkDefinitionId, string select = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (linkDefinitionId == null)
                throw new ArgumentNullException("linkDefinitionId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/LinkDefinitions/{linkDefinitionId}?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{linkDefinitionId}", Uri.EscapeDataString(ConvertToString(linkDefinitionId, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await GetLinkDefinitionSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<LinkDefinition> GetLinkDefinitionSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<LinkDefinition>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IEntriesClient
    {

        /// <summary>
        /// Requests Upload URLs to upload a large file in chunks.
        /// </summary>
        /// <remarks>
        /// - Requests Upload URLs to upload a large file in chunks.<br/>
        /// - Returns an UploadId and an array of URLs to which the file chunks should be written in the same order.<br/>
        /// - To request a new batch of Upload URLs for the same file, set the value of UploadId to the one returned when the first batch of Upload URLs was requested. For requesting the first batch of Upload URLs, leave UploadId empty or null.<br/>
        /// - Example: if a file is going to be uploaded in 10 chunks, the 10 Upload URLs can be retrieved by two successive calls to this api, each call requesting 5 Upload URLs. For this, the first call should have StartingPartNumber=1 and NumberOfParts=5, and the second call should have StartingPartNumber=6 and NumberOfParts=5, along with UploadId returned in the first call.<br/>
        /// - Each Upload URL expires after 15 minutes.<br/>
        /// - Each file chunk written to an Upload URL should be at least 5 MB and at most 5 GB. There is no minimum size limit for the last chunk.<br/>
        /// - The value of NumberOfParts must be in the range [1, 100], meaning that in each call to this api, a maximum of 100 Upload URLs can be requested. <br/>
        /// - The total number of Upload URLs for a single file is 1000, which means (StartingPartNumber + NumberOfParts) should be less than or equal to 1001.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="request">The request body.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A response containing an upload id and an array of upload URLs.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<CreateMultipartUploadUrlsResponse> CreateMultipartUploadUrlsAsync(string repositoryId, CreateMultipartUploadUrlsRequest request, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Starts an asynchronous import task to import a document into a folder.
        /// </summary>
        /// <remarks>
        /// - Imports a new file in the specified folder. The file should be already written (in chunks) to the upload URLs obtained by calling the Upload api.<br/>
        /// - This route does not support partial success.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The entry ID of the folder that the document will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<StartTaskResponse> StartImportUploadedPartsAsync(string repositoryId, int entryId, StartImportUploadedPartsRequest request = null, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Starts an asynchronous export task to export an entry.
        /// </summary>
        /// <remarks>
        /// - Starts an asynchronous export operation to export an entry.<br/>
        /// - If successful, it returns a taskId which can be used to check the status of the export operation or download the export result, otherwise, it returns an error.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of entry to export.</param>
        /// <param name="request">The request body.</param>
        /// <param name="pageRange">A comma-separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when part=Edoc.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<StartTaskResponse> StartExportEntryAsync(string repositoryId, int entryId, StartExportEntryRequest request, string pageRange = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Starts an asynchronous copy task to copy an entry into a folder.
        /// </summary>
        /// <remarks>
        /// - Copy a new child entry in the designated folder async, and potentially return a taskId.<br/>
        /// - Provide the parent folder ID, and copy an entry as a child of the designated folder.<br/>
        /// - The status of the operation can be checked via the Tasks route.<br/>
        /// - Token substitution in the name of the copied entry is not supported.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID that the entry will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<StartTaskResponse> StartCopyEntryAsync(string repositoryId, int entryId, StartCopyEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Starts an asynchronous delete task to delete an entry.
        /// </summary>
        /// <remarks>
        /// - Begins a task to delete an entry, and returns a taskId.<br/>
        /// - Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately.<br/>
        /// - Optionally include an audit reason ID and comment in the JSON body. This route returns a taskId, and will run as an asynchronous operation. Check the progress via the Tasks route.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The submitted audit reason.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<StartTaskResponse> StartDeleteEntryAsync(string repositoryId, int entryId, StartDeleteEntryRequest request = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns a single entry object.
        /// </summary>
        /// <remarks>
        /// - Returns a single entry object.<br/>
        /// - Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc.<br/>
        /// - If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.<br/>
        /// - Allowed OData query options: Select.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> GetEntryAsync(string repositoryId, int entryId, string select = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update an entry. (Move and/or Rename)
        /// </summary>
        /// <remarks>
        /// - Update an entry. (Move and/or Rename)<br/>
        /// - Move an entry to a new folder by setting the ParentId in the request body.<br/>
        /// - Rename an entry by setting the Name in the request body.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The request containing the folder ID that the entry will be moved to and the new name the entry will be renamed to.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> UpdateEntryAsync(string repositoryId, int entryId, UpdateEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Imports a file into a folder (max length: 100 MB).
        /// </summary>
        /// <remarks>
        /// - Import a new document in the specified folder, and optionally assigns metadata.<br/>
        /// - The import may fail if the file is greater than 100 MB or time out if it takes longer than 60 seconds. These values are subject to change at anytime. Use the long operation asynchronous import if you run into these restrictions.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The entry ID of the folder that the document will be created in.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The created entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> ImportEntryAsync(string repositoryId, int entryId, string culture = null, FileParameter file = null, ImportEntryRequest request = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Exports an entry.
        /// </summary>
        /// <remarks>
        /// - Export an entry.<br/>
        /// - The export may time out if it takes longer than 60 seconds. This value is subject to change at anytime. Use the long operation asynchronous export if you run into this restriction.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of entry to export.</param>
        /// <param name="request">The request body.</param>
        /// <param name="pageRange">A comma-separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when exporting as Edoc.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A link to download the exported entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<ExportEntryResponse> ExportEntryAsync(string repositoryId, int entryId, ExportEntryRequest request, string pageRange = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns a single entry object using the entry path.
        /// </summary>
        /// <remarks>
        /// - Returns a single entry object using the entry path.<br/>
        /// - Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="fullPath">The requested entry path.</param>
        /// <param name="fallbackToClosestAncestor">An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The found entry or ancestor entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<GetEntryByPathResponse> GetEntryByPathAsync(string repositoryId, string fullPath, bool? fallbackToClosestAncestor = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the children entries of a folder.
        /// </summary>
        /// <remarks>
        /// - Returns the children entries of a folder in the repository.<br/>
        /// - Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository.<br/>
        /// - Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route.<br/>
        /// - Optional query parameters: groupByEntryType (bool). This query parameter decides if results are returned in groups based on their entry type. <br/>
        /// - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.<br/>
        /// - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc".<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID.</param>
        /// <param name="groupByEntryType">Indicates if the result should be grouped by entry type or not. The default value is false.</param>
        /// <param name="fields">Optional array of field names. Field values corresponding to the given field names will be returned for each entry.</param>
        /// <param name="formatFieldValues">Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of children entries of a folder.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<EntryCollectionResponse> ListEntriesAsync(string repositoryId, int entryId, bool? groupByEntryType = null, IEnumerable<string> fields = null, bool? formatFieldValues = null, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Creates a new child entry in a folder.
        /// </summary>
        /// <remarks>
        /// - Create a new child entry in the designated folder.<br/>
        /// - Provide the parent folder ID, and based on the request body, create a folder/shortcut as a child entry of the designated folder.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID that the entry will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The created entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> CreateEntryAsync(string repositoryId, int entryId, CreateEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the fields assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns the fields assigned to an entry.<br/>
        /// - Provide an entry ID, and get a paged listing of all fields assigned to that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="formatFieldValues">An optional query parameter used to indicate if the field values should be formatted. The default value is false.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of fields assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<FieldCollectionResponse> ListFieldsAsync(string repositoryId, int entryId, string prefer = null, bool? formatFieldValues = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Updates the field values assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Update the field values assigned to an entry.<br/>
        /// - Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.<br/>
        /// - This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The entry ID of the entry that will have its fields updated.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of fields assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<FieldCollectionResponse> SetFieldsAsync(string repositoryId, int entryId, SetFieldsRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the tags assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns the tags assigned to an entry.<br/>
        /// - Provide an entry ID, and get a paged listing of tags assigned to that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of tags assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TagCollectionResponse> ListTagsAsync(string repositoryId, int entryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Assigns tags to an entry.
        /// </summary>
        /// <remarks>
        /// - Assign tags to an entry.<br/>
        /// - Provide an entry ID and a list of tags to assign to that entry.<br/>
        /// - This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The tags to add.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of tags assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TagCollectionResponse> SetTagsAsync(string repositoryId, int entryId, SetTagsRequest request, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Assigns links to an entry.
        /// </summary>
        /// <remarks>
        /// - Assign links to an entry.<br/>
        /// - Provide an entry ID and a list of links to assign to that entry.<br/>
        /// - This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The request repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The request body.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of links assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<LinkCollectionResponse> SetLinksAsync(string repositoryId, int entryId, SetLinksRequest request, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the links assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns the links assigned to an entry.<br/>
        /// - Provide an entry ID, and get a paged listing of links assigned to that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="prefer">An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of links assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<LinkCollectionResponse> ListLinksAsync(string repositoryId, int entryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Copies a new child entry in a folder.
        /// </summary>
        /// <remarks>
        /// - Copy a new child entry in the designated folder.<br/>
        /// - Provide the parent folder ID, and based on the request body, copy a child entry of the designated folder.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID that the entry will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The copied entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> CopyEntryAsync(string repositoryId, int entryId, CopyEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Deletes the edoc associated with an entry.
        /// </summary>
        /// <remarks>
        /// - Delete the edoc associated with the provided entry ID.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested document ID.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> DeleteElectronicDocumentAsync(string repositoryId, int entryId, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Deletes the pages associated with an entry.
        /// </summary>
        /// <remarks>
        /// - Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted.<br/>
        /// - Optional parameter: pageRange (default empty). The value should be a comma-separated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested document ID.</param>
        /// <param name="pageRange">The pages to be deleted.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> DeletePagesAsync(string repositoryId, int entryId, string pageRange = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the dynamic field logic values assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns dynamic field logic values with the current values of the fields in the template.<br/>
        /// - Provide an entry ID and field values in the JSON body to get dynamic field logic values.<br/>
        /// - Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The request body.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of dynamic field values.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<IDictionary<string, ICollection<string>>> ListDynamicFieldValuesAsync(string repositoryId, int entryId, ListDynamicFieldValuesRequest request, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Removes the currently assigned template from an entry.
        /// </summary>
        /// <remarks>
        /// - Remove the currently assigned template from the specified entry.<br/>
        /// - Provide an entry ID to clear template value on.<br/>
        /// - If the entry does not have a template assigned, no change will be made.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of the entry that will have its template removed.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> RemoveTemplateAsync(string repositoryId, int entryId, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Assigns a template to an entry.
        /// </summary>
        /// <remarks>
        /// - Assign a template to an entry.<br/>
        /// - Provide an entry ID, template name, and a list of template fields to assign to that entry.<br/>
        /// - Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of entry that will have its template updated.</param>
        /// <param name="request">The template and template fields that will be assigned to the entry.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<Entry> SetTemplateAsync(string repositoryId, int entryId, SetTemplateRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntriesClient : BaseClient, IEntriesClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public EntriesClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Requests Upload URLs to upload a large file in chunks.
        /// </summary>
        /// <remarks>
        /// - Requests Upload URLs to upload a large file in chunks.<br/>
        /// - Returns an UploadId and an array of URLs to which the file chunks should be written in the same order.<br/>
        /// - To request a new batch of Upload URLs for the same file, set the value of UploadId to the one returned when the first batch of Upload URLs was requested. For requesting the first batch of Upload URLs, leave UploadId empty or null.<br/>
        /// - Example: if a file is going to be uploaded in 10 chunks, the 10 Upload URLs can be retrieved by two successive calls to this api, each call requesting 5 Upload URLs. For this, the first call should have StartingPartNumber=1 and NumberOfParts=5, and the second call should have StartingPartNumber=6 and NumberOfParts=5, along with UploadId returned in the first call.<br/>
        /// - Each Upload URL expires after 15 minutes.<br/>
        /// - Each file chunk written to an Upload URL should be at least 5 MB and at most 5 GB. There is no minimum size limit for the last chunk.<br/>
        /// - The value of NumberOfParts must be in the range [1, 100], meaning that in each call to this api, a maximum of 100 Upload URLs can be requested. <br/>
        /// - The total number of Upload URLs for a single file is 1000, which means (StartingPartNumber + NumberOfParts) should be less than or equal to 1001.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="request">The request body.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A response containing an upload id and an array of upload URLs.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<CreateMultipartUploadUrlsResponse> CreateMultipartUploadUrlsAsync(string repositoryId, CreateMultipartUploadUrlsRequest request, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/CreateMultipartUploadUrls");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await CreateMultipartUploadUrlsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<CreateMultipartUploadUrlsResponse> CreateMultipartUploadUrlsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<CreateMultipartUploadUrlsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Starts an asynchronous import task to import a document into a folder.
        /// </summary>
        /// <remarks>
        /// - Imports a new file in the specified folder. The file should be already written (in chunks) to the upload URLs obtained by calling the Upload api.<br/>
        /// - This route does not support partial success.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The entry ID of the folder that the document will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<StartTaskResponse> StartImportUploadedPartsAsync(string repositoryId, int entryId, StartImportUploadedPartsRequest request = null, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/ImportUploadedParts?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await StartImportUploadedPartsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<StartTaskResponse> StartImportUploadedPartsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 202)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<StartTaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 500)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Starts an asynchronous export task to export an entry.
        /// </summary>
        /// <remarks>
        /// - Starts an asynchronous export operation to export an entry.<br/>
        /// - If successful, it returns a taskId which can be used to check the status of the export operation or download the export result, otherwise, it returns an error.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of entry to export.</param>
        /// <param name="request">The request body.</param>
        /// <param name="pageRange">A comma-separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when part=Edoc.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<StartTaskResponse> StartExportEntryAsync(string repositoryId, int entryId, StartExportEntryRequest request, string pageRange = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/ExportAsync?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (pageRange != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("pageRange") + "=").Append(Uri.EscapeDataString(ConvertToString(pageRange, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await StartExportEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<StartTaskResponse> StartExportEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 202)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<StartTaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 500)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Starts an asynchronous copy task to copy an entry into a folder.
        /// </summary>
        /// <remarks>
        /// - Copy a new child entry in the designated folder async, and potentially return a taskId.<br/>
        /// - Provide the parent folder ID, and copy an entry as a child of the designated folder.<br/>
        /// - The status of the operation can be checked via the Tasks route.<br/>
        /// - Token substitution in the name of the copied entry is not supported.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID that the entry will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<StartTaskResponse> StartCopyEntryAsync(string repositoryId, int entryId, StartCopyEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/CopyAsync?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await StartCopyEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<StartTaskResponse> StartCopyEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 202)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<StartTaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Starts an asynchronous delete task to delete an entry.
        /// </summary>
        /// <remarks>
        /// - Begins a task to delete an entry, and returns a taskId.<br/>
        /// - Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately.<br/>
        /// - Optionally include an audit reason ID and comment in the JSON body. This route returns a taskId, and will run as an asynchronous operation. Check the progress via the Tasks route.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The submitted audit reason.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<StartTaskResponse> StartDeleteEntryAsync(string repositoryId, int entryId, StartDeleteEntryRequest request = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("DELETE");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await StartDeleteEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<StartTaskResponse> StartDeleteEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 202)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<StartTaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns a single entry object.
        /// </summary>
        /// <remarks>
        /// - Returns a single entry object.<br/>
        /// - Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc.<br/>
        /// - If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.<br/>
        /// - Allowed OData query options: Select.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> GetEntryAsync(string repositoryId, int entryId, string select = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await GetEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> GetEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Update an entry. (Move and/or Rename)
        /// </summary>
        /// <remarks>
        /// - Update an entry. (Move and/or Rename)<br/>
        /// - Move an entry to a new folder by setting the ParentId in the request body.<br/>
        /// - Rename an entry by setting the Name in the request body.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The request containing the folder ID that the entry will be moved to and the new name the entry will be renamed to.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> UpdateEntryAsync(string repositoryId, int entryId, UpdateEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("PATCH");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await UpdateEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> UpdateEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 409)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Imports a file into a folder (max length: 100 MB).
        /// </summary>
        /// <remarks>
        /// - Import a new document in the specified folder, and optionally assigns metadata.<br/>
        /// - The import may fail if the file is greater than 100 MB or time out if it takes longer than 60 seconds. These values are subject to change at anytime. Use the long operation asynchronous import if you run into these restrictions.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The entry ID of the folder that the document will be created in.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The created entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> ImportEntryAsync(string repositoryId, int entryId, string culture = null, FileParameter file = null, ImportEntryRequest request = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Import?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var boundary_ = Guid.NewGuid().ToString();
                    var content_ = new MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);

                    if (file == null)
                        throw new ArgumentNullException("file");
                    else
                    {
                        var content_file_ = new StreamContent(file.Data);
                        if (!string.IsNullOrEmpty(file.ContentType))
                            content_file_.Headers.ContentType = MediaTypeHeaderValue.Parse(file.ContentType);
                        content_.Add(content_file_, "file", file.FileName ?? "file");
                    }

                    if (request == null)
                        throw new ArgumentNullException("request");
                    else
                    {
                        var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                        content_.Add(new StringContent(json_), "request");
                    }
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ImportEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> ImportEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 201)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 500)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Exports an entry.
        /// </summary>
        /// <remarks>
        /// - Export an entry.<br/>
        /// - The export may time out if it takes longer than 60 seconds. This value is subject to change at anytime. Use the long operation asynchronous export if you run into this restriction.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of entry to export.</param>
        /// <param name="request">The request body.</param>
        /// <param name="pageRange">A comma-separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when exporting as Edoc.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A link to download the exported entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<ExportEntryResponse> ExportEntryAsync(string repositoryId, int entryId, ExportEntryRequest request, string pageRange = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Export?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (pageRange != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("pageRange") + "=").Append(Uri.EscapeDataString(ConvertToString(pageRange, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ExportEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<ExportEntryResponse> ExportEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ExportEntryResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 500)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns a single entry object using the entry path.
        /// </summary>
        /// <remarks>
        /// - Returns a single entry object using the entry path.<br/>
        /// - Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="fullPath">The requested entry path.</param>
        /// <param name="fallbackToClosestAncestor">An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The found entry or ancestor entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<GetEntryByPathResponse> GetEntryByPathAsync(string repositoryId, string fullPath, bool? fallbackToClosestAncestor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (fullPath == null)
                throw new ArgumentNullException("fullPath");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/ByPath?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Append(Uri.EscapeDataString("fullPath") + "=").Append(Uri.EscapeDataString(ConvertToString(fullPath, CultureInfo.InvariantCulture))).Append("&");
            if (fallbackToClosestAncestor != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("fallbackToClosestAncestor") + "=").Append(Uri.EscapeDataString(ConvertToString(fallbackToClosestAncestor, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await GetEntryByPathSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<GetEntryByPathResponse> GetEntryByPathSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<GetEntryByPathResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the children entries of a folder.
        /// </summary>
        /// <remarks>
        /// - Returns the children entries of a folder in the repository.<br/>
        /// - Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository.<br/>
        /// - Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route.<br/>
        /// - Optional query parameters: groupByEntryType (bool). This query parameter decides if results are returned in groups based on their entry type. <br/>
        /// - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.<br/>
        /// - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc".<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID.</param>
        /// <param name="groupByEntryType">Indicates if the result should be grouped by entry type or not. The default value is false.</param>
        /// <param name="fields">Optional array of field names. Field values corresponding to the given field names will be returned for each entry.</param>
        /// <param name="formatFieldValues">Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of children entries of a folder.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<EntryCollectionResponse> ListEntriesAsync(string repositoryId, int entryId, bool? groupByEntryType = null, IEnumerable<string> fields = null, bool? formatFieldValues = null, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Children?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (groupByEntryType != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("groupByEntryType") + "=").Append(Uri.EscapeDataString(ConvertToString(groupByEntryType, CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null)
            {
                foreach (var item_ in fields) { urlBuilder_.Append(Uri.EscapeDataString("fields") + "=").Append(Uri.EscapeDataString(ConvertToString(item_, CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (formatFieldValues != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("formatFieldValues") + "=").Append(Uri.EscapeDataString(ConvertToString(formatFieldValues, CultureInfo.InvariantCulture))).Append("&");
            }
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListEntriesSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<EntryCollectionResponse> ListEntriesSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<EntryCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Creates a new child entry in a folder.
        /// </summary>
        /// <remarks>
        /// - Create a new child entry in the designated folder.<br/>
        /// - Provide the parent folder ID, and based on the request body, create a folder/shortcut as a child entry of the designated folder.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID that the entry will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The created entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> CreateEntryAsync(string repositoryId, int entryId, CreateEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Children?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await CreateEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> CreateEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 201)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 409)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the fields assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns the fields assigned to an entry.<br/>
        /// - Provide an entry ID, and get a paged listing of all fields assigned to that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="formatFieldValues">An optional query parameter used to indicate if the field values should be formatted. The default value is false.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of fields assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<FieldCollectionResponse> ListFieldsAsync(string repositoryId, int entryId, string prefer = null, bool? formatFieldValues = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Fields?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (formatFieldValues != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("formatFieldValues") + "=").Append(Uri.EscapeDataString(ConvertToString(formatFieldValues, CultureInfo.InvariantCulture))).Append("&");
            }
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListFieldsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<FieldCollectionResponse> ListFieldsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<FieldCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Updates the field values assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Update the field values assigned to an entry.<br/>
        /// - Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.<br/>
        /// - This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The entry ID of the entry that will have its fields updated.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of fields assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<FieldCollectionResponse> SetFieldsAsync(string repositoryId, int entryId, SetFieldsRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Fields?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("PUT");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await SetFieldsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<FieldCollectionResponse> SetFieldsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<FieldCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the tags assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns the tags assigned to an entry.<br/>
        /// - Provide an entry ID, and get a paged listing of tags assigned to that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of tags assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TagCollectionResponse> ListTagsAsync(string repositoryId, int entryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Tags?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListTagsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TagCollectionResponse> ListTagsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TagCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Assigns tags to an entry.
        /// </summary>
        /// <remarks>
        /// - Assign tags to an entry.<br/>
        /// - Provide an entry ID and a list of tags to assign to that entry.<br/>
        /// - This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The tags to add.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of tags assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TagCollectionResponse> SetTagsAsync(string repositoryId, int entryId, SetTagsRequest request, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Tags");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("PUT");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await SetTagsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TagCollectionResponse> SetTagsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TagCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Assigns links to an entry.
        /// </summary>
        /// <remarks>
        /// - Assign links to an entry.<br/>
        /// - Provide an entry ID and a list of links to assign to that entry.<br/>
        /// - This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The request repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The request body.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of links assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<LinkCollectionResponse> SetLinksAsync(string repositoryId, int entryId, SetLinksRequest request, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Links");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("PUT");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await SetLinksSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<LinkCollectionResponse> SetLinksSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<LinkCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the links assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns the links assigned to an entry.<br/>
        /// - Provide an entry ID, and get a paged listing of links assigned to that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="prefer">An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of links assigned to the entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<LinkCollectionResponse> ListLinksAsync(string repositoryId, int entryId, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Links?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListLinksSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<LinkCollectionResponse> ListLinksSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<LinkCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Copies a new child entry in a folder.
        /// </summary>
        /// <remarks>
        /// - Copy a new child entry in the designated folder.<br/>
        /// - Provide the parent folder ID, and based on the request body, copy a child entry of the designated folder.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The folder ID that the entry will be created in.</param>
        /// <param name="request">The request body.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The copied entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> CopyEntryAsync(string repositoryId, int entryId, CopyEntryRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Copy?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await CopyEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> CopyEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 201)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 409)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Deletes the edoc associated with an entry.
        /// </summary>
        /// <remarks>
        /// - Delete the edoc associated with the provided entry ID.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested document ID.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> DeleteElectronicDocumentAsync(string repositoryId, int entryId, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Document/Edoc");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("DELETE");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await DeleteElectronicDocumentSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> DeleteElectronicDocumentSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Deletes the pages associated with an entry.
        /// </summary>
        /// <remarks>
        /// - Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted.<br/>
        /// - Optional parameter: pageRange (default empty). The value should be a comma-separated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested document ID.</param>
        /// <param name="pageRange">The pages to be deleted.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> DeletePagesAsync(string repositoryId, int entryId, string pageRange = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Document/Pages?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (pageRange != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("pageRange") + "=").Append(Uri.EscapeDataString(ConvertToString(pageRange, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("DELETE");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await DeletePagesSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> DeletePagesSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the dynamic field logic values assigned to an entry.
        /// </summary>
        /// <remarks>
        /// - Returns dynamic field logic values with the current values of the fields in the template.<br/>
        /// - Provide an entry ID and field values in the JSON body to get dynamic field logic values.<br/>
        /// - Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The requested entry ID.</param>
        /// <param name="request">The request body.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of dynamic field values.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<IDictionary<string, ICollection<string>>> ListDynamicFieldValuesAsync(string repositoryId, int entryId, ListDynamicFieldValuesRequest request, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Fields/GetDynamicFieldLogicValue");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListDynamicFieldValuesSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<IDictionary<string, ICollection<string>>> ListDynamicFieldValuesSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<IDictionary<string, ICollection<string>>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Removes the currently assigned template from an entry.
        /// </summary>
        /// <remarks>
        /// - Remove the currently assigned template from the specified entry.<br/>
        /// - Provide an entry ID to clear template value on.<br/>
        /// - If the entry does not have a template assigned, no change will be made.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of the entry that will have its template removed.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> RemoveTemplateAsync(string repositoryId, int entryId, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Template");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("DELETE");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await RemoveTemplateSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> RemoveTemplateSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Assigns a template to an entry.
        /// </summary>
        /// <remarks>
        /// - Assign a template to an entry.<br/>
        /// - Provide an entry ID, template name, and a list of template fields to assign to that entry.<br/>
        /// - Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.<br/>
        /// - Required OAuth scope: repository.Write
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="entryId">The ID of entry that will have its template updated.</param>
        /// <param name="request">The template and template fields that will be assigned to the entry.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The updated entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<Entry> SetTemplateAsync(string repositoryId, int entryId, SetTemplateRequest request, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (entryId == null)
                throw new ArgumentNullException("entryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Entries/{entryId}/Template?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{entryId}", Uri.EscapeDataString(ConvertToString(entryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("PUT");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await SetTemplateSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<Entry> SetTemplateSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<Entry>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 423)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IRepositoriesClient
    {

        /// <summary>
        /// Returns the list of repositories accessible to the user.
        /// </summary>
        /// <remarks>
        /// - Returns the repository resource list that current user has access to.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of respositories.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<RepositoryCollectionResponse> ListRepositoriesAsync(CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RepositoriesClient : BaseClient, IRepositoriesClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public RepositoriesClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns the list of repositories accessible to the user.
        /// </summary>
        /// <remarks>
        /// - Returns the repository resource list that current user has access to.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of respositories.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<RepositoryCollectionResponse> ListRepositoriesAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories");

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListRepositoriesSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<RepositoryCollectionResponse> ListRepositoriesSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<RepositoryCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ISearchesClient
    {

        /// <summary>
        /// Starts an asynchronous search task.
        /// </summary>
        /// <remarks>
        /// - Runs a search operation on the repository.<br/>
        /// - The status for search operations must be checked via the Tasks route.<br/>
        /// - Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage).<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="request">The Laserfiche search command to run, optionally include fuzzy search settings.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<StartTaskResponse> StartSearchEntryAsync(string repositoryId, StartSearchEntryRequest request, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the results listing associated with a search task.
        /// </summary>
        /// <remarks>
        /// - Returns a search result listing if the search is completed.<br/>
        /// - Search results expire after 5 minutes, but can be refreshed by retrieving the results again.<br/>
        /// - Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type.<br/>
        /// - Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values.<br/>
        /// - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.<br/>
        /// - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc".<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="taskId">The requested task ID.</param>
        /// <param name="groupByEntryType">Indicates if the result should be grouped by entry type or not. The default value is false.</param>
        /// <param name="refresh">Indicates if the search listing should be refreshed to show updated values. The default value is false.</param>
        /// <param name="fields">Optional array of field names. Field values corresponding to the given field names will be returned for each search result.</param>
        /// <param name="formatFieldValues">Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.</param>
        /// <param name="prefer">An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of entry search results.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<EntryCollectionResponse> ListSearchResultsAsync(string repositoryId, string taskId, bool? groupByEntryType = null, bool? refresh = null, IEnumerable<string> fields = null, bool? formatFieldValues = null, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the context hits associated with a search result entry.
        /// </summary>
        /// <remarks>
        /// - Returns the context hits associated with a search result entry.<br/>
        /// - Given a taskId, and rowNumber associated with a search entry in the listing, return the context hits for that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="taskId">The requested task ID.</param>
        /// <param name="rowNumber">The search result listing row number to get context hits for.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of context hits for a search result.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<SearchContextHitCollectionResponse> ListSearchContextHitsAsync(string repositoryId, string taskId, int rowNumber, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchesClient : BaseClient, ISearchesClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public SearchesClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Starts an asynchronous search task.
        /// </summary>
        /// <remarks>
        /// - Runs a search operation on the repository.<br/>
        /// - The status for search operations must be checked via the Tasks route.<br/>
        /// - Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage).<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="request">The Laserfiche search command to run, optionally include fuzzy search settings.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A long operation task id.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<StartTaskResponse> StartSearchEntryAsync(string repositoryId, StartSearchEntryRequest request, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Searches/SearchAsync");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await StartSearchEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<StartTaskResponse> StartSearchEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 202)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<StartTaskResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the results listing associated with a search task.
        /// </summary>
        /// <remarks>
        /// - Returns a search result listing if the search is completed.<br/>
        /// - Search results expire after 5 minutes, but can be refreshed by retrieving the results again.<br/>
        /// - Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type.<br/>
        /// - Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values.<br/>
        /// - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.<br/>
        /// - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc".<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="taskId">The requested task ID.</param>
        /// <param name="groupByEntryType">Indicates if the result should be grouped by entry type or not. The default value is false.</param>
        /// <param name="refresh">Indicates if the search listing should be refreshed to show updated values. The default value is false.</param>
        /// <param name="fields">Optional array of field names. Field values corresponding to the given field names will be returned for each search result.</param>
        /// <param name="formatFieldValues">Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.</param>
        /// <param name="prefer">An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of entry search results.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<EntryCollectionResponse> ListSearchResultsAsync(string repositoryId, string taskId, bool? groupByEntryType = null, bool? refresh = null, IEnumerable<string> fields = null, bool? formatFieldValues = null, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (taskId == null)
                throw new ArgumentNullException("taskId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Searches/{taskId}/Results?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{taskId}", Uri.EscapeDataString(ConvertToString(taskId, CultureInfo.InvariantCulture)));
            if (groupByEntryType != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("groupByEntryType") + "=").Append(Uri.EscapeDataString(ConvertToString(groupByEntryType, CultureInfo.InvariantCulture))).Append("&");
            }
            if (refresh != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("refresh") + "=").Append(Uri.EscapeDataString(ConvertToString(refresh, CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null)
            {
                foreach (var item_ in fields) { urlBuilder_.Append(Uri.EscapeDataString("fields") + "=").Append(Uri.EscapeDataString(ConvertToString(item_, CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (formatFieldValues != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("formatFieldValues") + "=").Append(Uri.EscapeDataString(ConvertToString(formatFieldValues, CultureInfo.InvariantCulture))).Append("&");
            }
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListSearchResultsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<EntryCollectionResponse> ListSearchResultsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<EntryCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the context hits associated with a search result entry.
        /// </summary>
        /// <remarks>
        /// - Returns the context hits associated with a search result entry.<br/>
        /// - Given a taskId, and rowNumber associated with a search entry in the listing, return the context hits for that entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="taskId">The requested task ID.</param>
        /// <param name="rowNumber">The search result listing row number to get context hits for.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of context hits for a search result.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<SearchContextHitCollectionResponse> ListSearchContextHitsAsync(string repositoryId, string taskId, int rowNumber, string prefer = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (taskId == null)
                throw new ArgumentNullException("taskId");

            if (rowNumber == null)
                throw new ArgumentNullException("rowNumber");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Searches/{taskId}/Results/{rowNumber}/ContextHits?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{taskId}", Uri.EscapeDataString(ConvertToString(taskId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{rowNumber}", Uri.EscapeDataString(ConvertToString(rowNumber, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListSearchContextHitsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<SearchContextHitCollectionResponse> ListSearchContextHitsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<SearchContextHitCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ISimpleSearchesClient
    {

        /// <summary>
        /// Runs a "simple" search operation.
        /// </summary>
        /// <remarks>
        /// - Runs a "simple" search operation on the repository.<br/>
        /// - Returns a truncated search result listing.<br/>
        /// - Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches.<br/>
        /// - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="request">The Laserfiche search command to run.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="fields">Optional array of field names. Field values corresponding to the given field names will be returned for each search result.</param>
        /// <param name="formatFieldValues">Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of entry search results.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<EntryCollectionResponse> SearchEntryAsync(string repositoryId, SearchEntryRequest request, string select = null, string orderby = null, bool? count = null, IEnumerable<string> fields = null, bool? formatFieldValues = null, string culture = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SimpleSearchesClient : BaseClient, ISimpleSearchesClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public SimpleSearchesClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Runs a "simple" search operation.
        /// </summary>
        /// <remarks>
        /// - Runs a "simple" search operation on the repository.<br/>
        /// - Returns a truncated search result listing.<br/>
        /// - Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches.<br/>
        /// - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="request">The Laserfiche search command to run.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="fields">Optional array of field names. Field values corresponding to the given field names will be returned for each search result.</param>
        /// <param name="formatFieldValues">Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of entry search results.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<EntryCollectionResponse> SearchEntryAsync(string repositoryId, SearchEntryRequest request, string select = null, string orderby = null, bool? count = null, IEnumerable<string> fields = null, bool? formatFieldValues = null, string culture = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (request == null)
                throw new ArgumentNullException("request");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/SimpleSearches?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null)
            {
                foreach (var item_ in fields) { urlBuilder_.Append(Uri.EscapeDataString("fields") + "=").Append(Uri.EscapeDataString(ConvertToString(item_, CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (formatFieldValues != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("formatFieldValues") + "=").Append(Uri.EscapeDataString(ConvertToString(formatFieldValues, CultureInfo.InvariantCulture))).Append("&");
            }
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value);
                    var content_ = new StringContent(json_);
                    content_.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new HttpMethod("POST");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await SearchEntrySendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<EntryCollectionResponse> SearchEntrySendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<EntryCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 206)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<EntryCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 413)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ITagDefinitionsClient
    {

        /// <summary>
        /// Returns the tag definitions associated with a repository.
        /// </summary>
        /// <remarks>
        /// - Returns all tag definitions in the repository.<br/>
        /// - Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of tag definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TagDefinitionCollectionResponse> ListTagDefinitionsAsync(string repositoryId, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns a single tag definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single tag definition.<br/>
        /// - Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="tagId">The requested tag definition ID.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single tag definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TagDefinition> GetTagDefinitionAsync(string repositoryId, int tagId, string culture = null, string select = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagDefinitionsClient : BaseClient, ITagDefinitionsClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public TagDefinitionsClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns the tag definitions associated with a repository.
        /// </summary>
        /// <remarks>
        /// - Returns all tag definitions in the repository.<br/>
        /// - Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of tag definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TagDefinitionCollectionResponse> ListTagDefinitionsAsync(string repositoryId, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/TagDefinitions?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListTagDefinitionsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TagDefinitionCollectionResponse> ListTagDefinitionsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TagDefinitionCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns a single tag definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single tag definition.<br/>
        /// - Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="tagId">The requested tag definition ID.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single tag definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TagDefinition> GetTagDefinitionAsync(string repositoryId, int tagId, string culture = null, string select = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (tagId == null)
                throw new ArgumentNullException("tagId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/TagDefinitions/{tagId}?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tagId}", Uri.EscapeDataString(ConvertToString(tagId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await GetTagDefinitionSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TagDefinition> GetTagDefinitionSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TagDefinition>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ITasksClient
    {

        /// <summary>
        /// Returns the status of a set of one or more tasks.
        /// </summary>
        /// <remarks>
        /// - Returns the status of a set of one or more tasks.<br/>
        /// - Provide a comma-separated list of task IDs to get the task status, progress, and any errors that may have occurred.<br/>
        /// - Leave the taskIds query parameter empty, to get the list of all the task IDs associated with the current access token.<br/>
        /// - TaskStatus can be one of the following values: NotStarted, InProgress, Completed, Cancelled, or Failed.<br/>
        /// - This API employs long polling technique and could return the result immediately (e.g. if the export operation is failed or completed successfully) or after atmost 60 seconds.<br/>
        /// - Required OAuth scope: None
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID</param>
        /// <param name="taskIds">An array of task IDs. Leave this parameter empty to get the list of all the tasks associated with the current access token.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of task progresses.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TaskCollectionResponse> ListTasksAsync(string repositoryId, IEnumerable<string> taskIds = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Starts the cancellation for a set of one or more tasks.
        /// </summary>
        /// <remarks>
        /// - Starts the cancellation for a set of one or more tasks.<br/>
        /// - Provide comma-separated list of task IDs to cancel. Should be used if an operation was created in error, or is no longer necessary.<br/>
        /// - Check the status of the task to determine if the task has been cancelled successfully.<br/>
        /// - Leave the taskIds query parameter empty, to cancel the list of all the task IDs associated with the current access token.<br/>
        /// - Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.<br/>
        /// - Required OAuth scope: None
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID</param>
        /// <param name="taskIds">An array of task IDs. Leave this parameter empty to cancel the list of all the tasks associated with the current access token.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of task cancellation results.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<CancelTasksResponse> CancelTasksAsync(string repositoryId, IEnumerable<string> taskIds = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TasksClient : BaseClient, ITasksClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public TasksClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns the status of a set of one or more tasks.
        /// </summary>
        /// <remarks>
        /// - Returns the status of a set of one or more tasks.<br/>
        /// - Provide a comma-separated list of task IDs to get the task status, progress, and any errors that may have occurred.<br/>
        /// - Leave the taskIds query parameter empty, to get the list of all the task IDs associated with the current access token.<br/>
        /// - TaskStatus can be one of the following values: NotStarted, InProgress, Completed, Cancelled, or Failed.<br/>
        /// - This API employs long polling technique and could return the result immediately (e.g. if the export operation is failed or completed successfully) or after atmost 60 seconds.<br/>
        /// - Required OAuth scope: None
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID</param>
        /// <param name="taskIds">An array of task IDs. Leave this parameter empty to get the list of all the tasks associated with the current access token.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of task progresses.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TaskCollectionResponse> ListTasksAsync(string repositoryId, IEnumerable<string> taskIds = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Tasks?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (taskIds != null)
            {
                foreach (var item_ in taskIds) { urlBuilder_.Append(Uri.EscapeDataString("taskIds") + "=").Append(Uri.EscapeDataString(ConvertToString(item_, CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListTasksSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TaskCollectionResponse> ListTasksSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TaskCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Starts the cancellation for a set of one or more tasks.
        /// </summary>
        /// <remarks>
        /// - Starts the cancellation for a set of one or more tasks.<br/>
        /// - Provide comma-separated list of task IDs to cancel. Should be used if an operation was created in error, or is no longer necessary.<br/>
        /// - Check the status of the task to determine if the task has been cancelled successfully.<br/>
        /// - Leave the taskIds query parameter empty, to cancel the list of all the task IDs associated with the current access token.<br/>
        /// - Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.<br/>
        /// - Required OAuth scope: None
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID</param>
        /// <param name="taskIds">An array of task IDs. Leave this parameter empty to cancel the list of all the tasks associated with the current access token.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of task cancellation results.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<CancelTasksResponse> CancelTasksAsync(string repositoryId, IEnumerable<string> taskIds = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/Tasks?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (taskIds != null)
            {
                foreach (var item_ in taskIds) { urlBuilder_.Append(Uri.EscapeDataString("taskIds") + "=").Append(Uri.EscapeDataString(ConvertToString(item_, CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("DELETE");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await CancelTasksSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<CancelTasksResponse> CancelTasksSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<CancelTasksResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ITemplateDefinitionsClient
    {

        /// <summary>
        /// Returns the template definitions associated with a repository.
        /// </summary>
        /// <remarks>
        /// - Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned.<br/>
        /// - Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateName">An optional query parameter. Can be used to get a single template definition using the template name.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of template definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TemplateDefinitionCollectionResponse> ListTemplateDefinitionsAsync(string repositoryId, string templateName = null, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns a single template definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single template definition (including field definitions, if relevant).<br/>
        /// - Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateId">The requested template definition ID.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single template definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TemplateDefinition> GetTemplateDefinitionAsync(string repositoryId, int templateId, string culture = null, string select = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the field definitions assigned to a template definition (by template definition ID).
        /// </summary>
        /// <remarks>
        /// - Returns the field definitions assigned to a template definition.<br/>
        /// - Provide a template definition ID, and get a paged listing of the field definitions assigned to that template. <br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateId">The requested template definition ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of template field definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TemplateFieldDefinitionCollectionResponse> ListTemplateFieldDefinitionsByTemplateIdAsync(string repositoryId, int templateId, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the field definitions assigned to a template definition (by template definition name).
        /// </summary>
        /// <remarks>
        /// - Returns the field definitions assigned to a template definition.<br/>
        /// - Provide a template definition name, and get a paged listing of the field definitions assigned to that template. <br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateName">A required query parameter for the requested template name.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of template field definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        Task<TemplateFieldDefinitionCollectionResponse> ListTemplateFieldDefinitionsByTemplateNameAsync(string repositoryId, string templateName, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken));

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TemplateDefinitionsClient : BaseClient, ITemplateDefinitionsClient
    {
        private HttpClient _httpClient;
        private Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public TemplateDefinitionsClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, HttpRequestMessage request, StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, HttpResponseMessage response);

        /// <summary>
        /// Returns the template definitions associated with a repository.
        /// </summary>
        /// <remarks>
        /// - Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned.<br/>
        /// - Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one.<br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateName">An optional query parameter. Can be used to get a single template definition using the template name.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of template definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TemplateDefinitionCollectionResponse> ListTemplateDefinitionsAsync(string repositoryId, string templateName = null, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/TemplateDefinitions?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            if (templateName != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("templateName") + "=").Append(Uri.EscapeDataString(ConvertToString(templateName, CultureInfo.InvariantCulture))).Append("&");
            }
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListTemplateDefinitionsSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TemplateDefinitionCollectionResponse> ListTemplateDefinitionsSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TemplateDefinitionCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns a single template definition object.
        /// </summary>
        /// <remarks>
        /// - Returns a single template definition (including field definitions, if relevant).<br/>
        /// - Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed.<br/>
        /// - Allowed OData query options: Select<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateId">The requested template definition ID.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A single template definition.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TemplateDefinition> GetTemplateDefinitionAsync(string repositoryId, int templateId, string culture = null, string select = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (templateId == null)
                throw new ArgumentNullException("templateId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/TemplateDefinitions/{templateId}?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{templateId}", Uri.EscapeDataString(ConvertToString(templateId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await GetTemplateDefinitionSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TemplateDefinition> GetTemplateDefinitionSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TemplateDefinition>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the field definitions assigned to a template definition (by template definition ID).
        /// </summary>
        /// <remarks>
        /// - Returns the field definitions assigned to a template definition.<br/>
        /// - Provide a template definition ID, and get a paged listing of the field definitions assigned to that template. <br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateId">The requested template definition ID.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of template field definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TemplateFieldDefinitionCollectionResponse> ListTemplateFieldDefinitionsByTemplateIdAsync(string repositoryId, int templateId, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (templateId == null)
                throw new ArgumentNullException("templateId");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/TemplateDefinitions/{templateId}/FieldDefinitions?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{templateId}", Uri.EscapeDataString(ConvertToString(templateId, CultureInfo.InvariantCulture)));
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListTemplateFieldDefinitionsByTemplateIdSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TemplateFieldDefinitionCollectionResponse> ListTemplateFieldDefinitionsByTemplateIdSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TemplateFieldDefinitionCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        /// <summary>
        /// Returns the field definitions assigned to a template definition (by template definition name).
        /// </summary>
        /// <remarks>
        /// - Returns the field definitions assigned to a template definition.<br/>
        /// - Provide a template definition name, and get a paged listing of the field definitions assigned to that template. <br/>
        /// - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.<br/>
        /// - Required OAuth scope: repository.Read
        /// </remarks>
        /// <param name="repositoryId">The requested repository ID.</param>
        /// <param name="templateName">A required query parameter for the requested template name.</param>
        /// <param name="prefer">An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.</param>
        /// <param name="culture">An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.</param>
        /// <param name="select">Limits the properties returned in the result.</param>
        /// <param name="orderby">Specifies the order in which items are returned. The maximum number of expressions is 5.</param>
        /// <param name="top">Limits the number of items returned from a collection.</param>
        /// <param name="skip">Excludes the specified number of items of the queried collection from the result.</param>
        /// <param name="count">Indicates whether the total count of items within a collection are returned in the result.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A collection of template field definitions.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async Task<TemplateFieldDefinitionCollectionResponse> ListTemplateFieldDefinitionsByTemplateNameAsync(string repositoryId, string templateName, string prefer = null, string culture = null, string select = null, string orderby = null, int? top = null, int? skip = null, bool? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (repositoryId == null)
                throw new ArgumentNullException("repositoryId");

            if (templateName == null)
                throw new ArgumentNullException("templateName");

            var urlBuilder_ = new StringBuilder();
            urlBuilder_.Append("v2/Repositories/{repositoryId}/TemplateDefinitions/FieldDefinitions?");
            urlBuilder_.Replace("{repositoryId}", Uri.EscapeDataString(ConvertToString(repositoryId, CultureInfo.InvariantCulture)));
            urlBuilder_.Append(Uri.EscapeDataString("templateName") + "=").Append(Uri.EscapeDataString(ConvertToString(templateName, CultureInfo.InvariantCulture))).Append("&");
            if (culture != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("culture") + "=").Append(Uri.EscapeDataString(ConvertToString(culture, CultureInfo.InvariantCulture))).Append("&");
            }
            if (select != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$select") + "=").Append(Uri.EscapeDataString(ConvertToString(select, CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderby != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$orderby") + "=").Append(Uri.EscapeDataString(ConvertToString(orderby, CultureInfo.InvariantCulture))).Append("&");
            }
            if (top != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$top") + "=").Append(Uri.EscapeDataString(ConvertToString(top, CultureInfo.InvariantCulture))).Append("&");
            }
            if (skip != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$skip") + "=").Append(Uri.EscapeDataString(ConvertToString(skip, CultureInfo.InvariantCulture))).Append("&");
            }
            if (count != null)
            {
                urlBuilder_.Append(Uri.EscapeDataString("$count") + "=").Append(Uri.EscapeDataString(ConvertToString(count, CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            bool[] disposeClient_ = new bool[]{ false };
            try
            {
                using (var request_ = new HttpRequestMessage())
                {

                    if (prefer != null)
                        request_.Headers.TryAddWithoutValidation("Prefer", ConvertToString(prefer, CultureInfo.InvariantCulture));
                    request_.Method = new HttpMethod("GET");
                    request_.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new Uri(url_, UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    return await ListTemplateFieldDefinitionsByTemplateNameSendAsync(request_, client_, disposeClient_, cancellationToken);
                }
            }
            finally
            {
                if (disposeClient_[0])
                    client_.Dispose();
            }
        }

        protected virtual async Task<TemplateFieldDefinitionCollectionResponse> ListTemplateFieldDefinitionsByTemplateNameSendAsync(HttpRequestMessage request_, HttpClient client_, bool[] disposeClient_, CancellationToken cancellationToken = default(CancellationToken))
        {
            var response_ = await client_.SendAsync(request_, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            var disposeResponse_ = true;
            try
            {
                var headers_ = Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                if (response_.Content != null && response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = (int)response_.StatusCode;
                if (status_ == 200)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<TemplateFieldDefinitionCollectionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    return objectResponse_.Object;
                }
                else
                if (status_ == 400)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 401)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 403)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 404)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                if (status_ == 429)
                {
                    var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                    if (objectResponse_.Object == null)
                    {
                        throw ApiExceptionExtensions.Create(status_, headers_, null);
                    }
                    throw ApiExceptionExtensions.Create(status_, headers_, objectResponse_.Object, null);
                }
                else
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw ApiExceptionExtensions.Create(status_, headers_, responseData_, JsonSerializerSettings, null);
                }
            }
            finally
            {
                if (disposeResponse_)
                    response_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(HttpResponseMessage response, IReadOnlyDictionary<string, IEnumerable<string>> headers, CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, responseText, JsonSerializerSettings, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw ApiExceptionExtensions.Create((int)response.StatusCode, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is Enum)
            {
                var name = Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = CustomAttributeExtensions.GetCustomAttribute(field, typeof(EnumMemberAttribute)) 
                            as EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = Convert.ToString(Convert.ChangeType(value, Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = Enumerable.OfType<object>((Array) value);
                return string.Join(",", Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// Response containing a collection of Attribute.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AttributeCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<Attribute> Value { get; set; }

    }

    /// <summary>
    /// Represents a trustee attribute.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Attribute
    {
        /// <summary>
        /// The attribute key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        /// <summary>
        /// The attribute value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// Response containing a collection of AuditReason.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuditReasonCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<AuditReason> Value { get; set; }

    }

    /// <summary>
    /// Represents a user-defined audit reason for an audit event.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuditReason
    {
        /// <summary>
        /// The audit reason id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The audit reason text.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The audit event type for this audit reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auditEventType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AuditEventType AuditEventType { get; set; }

    }

    /// <summary>
    /// Enumeration of Laserfiche audit event types.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AuditEventType
    {

        [EnumMember(Value = @"DeleteEntry")]
        DeleteEntry = 0,

        [EnumMember(Value = @"ExportDocument")]
        ExportDocument = 1,

    }

    /// <summary>
    /// Represents a field definition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FieldDefinition
    {
        /// <summary>
        /// The name of the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The localized name of the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// The ID of the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The description of the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The type of the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FieldType FieldType { get; set; }

        /// <summary>
        /// The length of the field for variable length data types.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("length", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Length { get; set; }

        /// <summary>
        /// The default value of the field for new entries that are assigned to a template the represented field is a member of.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DefaultValue { get; set; }

        /// <summary>
        /// A boolean indicating if the represented template field supports multiple values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isMultiValue", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsMultiValue { get; set; }

        /// <summary>
        /// A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isRequired", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsRequired { get; set; }

        /// <summary>
        /// The constraint for values stored in the represented field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Constraint { get; set; }

        /// <summary>
        /// The error string that will be returned when the field constraint is violated when setting a value for this field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraintError", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConstraintError { get; set; }

        /// <summary>
        /// The list of items assigned to the represented field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("listValues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<string> ListValues { get; set; }

        /// <summary>
        /// The display format of the represented field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FieldFormat Format { get; set; }

        /// <summary>
        /// The name of the currency that will be using when formatting the represented field when the Format property is set to the Currency member of the WFieldFormat enumeration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Currency { get; set; }

        /// <summary>
        /// The custom format pattern for fields that are configured to use a custom format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formatPattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FormatPattern { get; set; }

    }

    /// <summary>
    /// Enumeration of Laserfiche template field types.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FieldType
    {

        [EnumMember(Value = @"DateTime")]
        DateTime = 0,

        [EnumMember(Value = @"Blob")]
        Blob = 1,

        [EnumMember(Value = @"Date")]
        Date = 2,

        [EnumMember(Value = @"ShortInteger")]
        ShortInteger = 3,

        [EnumMember(Value = @"LongInteger")]
        LongInteger = 4,

        [EnumMember(Value = @"List")]
        List = 5,

        [EnumMember(Value = @"Number")]
        Number = 6,

        [EnumMember(Value = @"String")]
        String = 7,

        [EnumMember(Value = @"Time")]
        Time = 8,

    }

    /// <summary>
    /// Enumeration of Laserfiche template field formats.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FieldFormat
    {

        [EnumMember(Value = @"None")]
        None = 0,

        [EnumMember(Value = @"ShortDate")]
        ShortDate = 1,

        [EnumMember(Value = @"LongDate")]
        LongDate = 2,

        [EnumMember(Value = @"ShortDateTime")]
        ShortDateTime = 3,

        [EnumMember(Value = @"LongDateTime")]
        LongDateTime = 4,

        [EnumMember(Value = @"ShortTime")]
        ShortTime = 5,

        [EnumMember(Value = @"LongTime")]
        LongTime = 6,

        [EnumMember(Value = @"GeneralNumber")]
        GeneralNumber = 7,

        [EnumMember(Value = @"Currency")]
        Currency = 8,

        [EnumMember(Value = @"Percent")]
        Percent = 9,

        [EnumMember(Value = @"Scientific")]
        Scientific = 10,

        [EnumMember(Value = @"Custom")]
        Custom = 11,

    }

    /// <summary>
    /// Response containing a collection of FieldDefinition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FieldDefinitionCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<FieldDefinition> Value { get; set; }

    }

    /// <summary>
    /// Response containing a collection of LinkDefinition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LinkDefinitionCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<LinkDefinition> Value { get; set; }

    }

    /// <summary>
    /// Represents an entry link definition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LinkDefinition
    {
        /// <summary>
        /// The ID of the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The label for the source entry in the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceLabel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceLabel { get; set; }

        /// <summary>
        /// The label for the target entry in the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetLabel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetLabel { get; set; }

        /// <summary>
        /// The description of the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

    }

    /// <summary>
    /// Response for CreateMultipartUploadUrls.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateMultipartUploadUrlsResponse
    {
        /// <summary>
        /// A unique identifier for the whole upload process.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uploadId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UploadId { get; set; }

        /// <summary>
        /// A list of URLs to which the file chunk should be written.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("urls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<string> Urls { get; set; }

    }

    /// <summary>
    /// Request body for creating multipart upload urls.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateMultipartUploadUrlsRequest
    {
        /// <summary>
        /// A unique identifier for the whole upload process.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uploadId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UploadId { get; set; } = "";

        /// <summary>
        /// Determines the starting position of the requested parts among all the parts associated with this upload. The default value is 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startingPartNumber", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int StartingPartNumber { get; set; } = 1;

        /// <summary>
        /// The value must be in the range [1, 100], meaning that in each call to the CreateMultipartUploadUrls api, a maximum of 100 Upload URLs can be requested. Further, each file chunk written to an Upload URL should be at least 5 MB. There is no minimum size limit for the last chunk.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("numberOfParts", Required = Newtonsoft.Json.Required.Always)]
        public int NumberOfParts { get; set; }

        /// <summary>
        /// The name of the file to be uploaded. The file extension in the name will be used as the extension of the imported entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileName { get; set; }

        /// <summary>
        /// The mime-type of the file to be uploaded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mimeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MimeType { get; set; }

    }

    /// <summary>
    /// Response containing a long operation task id.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StartTaskResponse
    {
        /// <summary>
        /// A task ID that can be used to check on the status of the task.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("taskId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TaskId { get; set; }

    }

    /// <summary>
    /// Request body for starting an asynchronous import entry task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StartImportUploadedPartsRequest
    {
        /// <summary>
        /// The UploadId received when calling the CreateMultipartUploadUrls API to request upload URLs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uploadId", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string UploadId { get; set; }

        /// <summary>
        /// The array of the ETag values received when writing the file chunks into the upload URLs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partETags", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public IList<string> PartETags { get; set; } = new Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// The name for the imported entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string Name { get; set; }

        /// <summary>
        /// Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoRename", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AutoRename { get; set; } = false;

        /// <summary>
        /// The options applied when importing a PDF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pdfOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ImportEntryRequestPdfOptions PdfOptions { get; set; }

        /// <summary>
        /// Indicates if the document should be imported as an electronic document (true) or as image pages (false). The default value is false. This option is only applicable when importing the following document types: txt, tif, tiff, bmp, pcx, jpg, jpeg, gif, png.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("importAsElectronicDocument", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ImportAsElectronicDocument { get; set; } = false;

        /// <summary>
        /// The metadata that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ImportEntryRequestMetadata Metadata { get; set; }

        /// <summary>
        /// The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

    }

    /// <summary>
    /// PDF-related options for importing an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImportEntryRequestPdfOptions
    {
        /// <summary>
        /// Indicates if the import operation should generate text. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("generateText", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool GenerateText { get; set; } = false;

        /// <summary>
        /// Indicates if the import operation should generate image pages. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("generatePages", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool GeneratePages { get; set; } = false;

        /// <summary>
        /// The image type used when generating image pages. The default value is StandardColor. This option is only applicable when GeneratePages is true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("generatePagesImageType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GeneratePagesImageType GeneratePagesImageType { get; set; } = Laserfiche.Repository.Api.Client.GeneratePagesImageType.StandardColor;

        /// <summary>
        /// Indicates if the PDF file should be retained as an electronic document after generating image pages. The default value is true. This option is only applicable when GeneratePages is true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keepPdfAfterImport", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool KeepPdfAfterImport { get; set; } = true;

    }

    /// <summary>
    /// Enumeration for the image types when generating pages.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum GeneratePagesImageType
    {

        [EnumMember(Value = @"BlackAndWhite")]
        BlackAndWhite = 0,

        [EnumMember(Value = @"StandardColor")]
        StandardColor = 1,

        [EnumMember(Value = @"HighQualityColor")]
        HighQualityColor = 2,

    }

    /// <summary>
    /// Represents the metadata that will be assigned to the imported entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImportEntryRequestMetadata
    {
        /// <summary>
        /// The name of the template assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TemplateName { get; set; }

        /// <summary>
        /// The fields that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<FieldToUpdate> Fields { get; set; }

        /// <summary>
        /// The tags that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<string> Tags { get; set; }

        /// <summary>
        /// The links that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<LinkToUpdate> Links { get; set; }

    }

    /// <summary>
    /// Represents a field that will be assigned to the entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FieldToUpdate
    {
        /// <summary>
        /// The name of the field that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string Name { get; set; }

        /// <summary>
        /// The field values that will be assigned to the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<string> Values { get; set; }

    }

    /// <summary>
    /// Represents a link that will be assigned to the entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LinkToUpdate
    {
        /// <summary>
        /// The id of the link definition to be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkDefinitionId", Required = Newtonsoft.Json.Required.Always)]
        public int LinkDefinitionId { get; set; }

        /// <summary>
        /// The id of the other entry to be linked to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("otherEntryId", Required = Newtonsoft.Json.Required.Always)]
        public int OtherEntryId { get; set; }

        /// <summary>
        /// Whether the entry is the source for the link. The default value is true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isSource", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsSource { get; set; } = true;

        /// <summary>
        /// Custom properties (key, value pairs) to be added to the link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IDictionary<string, string> CustomProperties { get; set; }

    }

    /// <summary>
    /// Request body for starting an asynchronous export entry task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StartExportEntryRequest
    {
        /// <summary>
        /// The reason id for this audit event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auditReasonId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int AuditReasonId { get; set; }

        /// <summary>
        /// The comment for this audit event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auditReasonComment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuditReasonComment { get; set; } = "";

        /// <summary>
        /// Specifies the part of the document to export.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("part", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ExportEntryRequestPart Part { get; set; }

        /// <summary>
        /// The options applied when exporting as Image.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imageOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExportEntryRequestImageOptions ImageOptions { get; set; }

        /// <summary>
        /// The options applied when exporting as Text.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("textOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExportEntryRequestTextOptions TextOptions { get; set; }

    }

    /// <summary>
    /// Enumeration of the entry parts to export.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExportEntryRequestPart
    {

        [EnumMember(Value = @"Image")]
        Image = 0,

        [EnumMember(Value = @"Text")]
        Text = 1,

        [EnumMember(Value = @"Edoc")]
        Edoc = 2,

    }

    /// <summary>
    /// Represents the options when exporting the image part of an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportEntryRequestImageOptions
    {
        /// <summary>
        /// The image format to export as. Options include: MultiPageTIFF, SinglePageTIFF, PNG, PDF and JPEG. The default value is MultiPageTIFF. MultiPageTIFF format is a single multi-page TIFF file. SinglePageTIFF format is multiple single-page TIFF files (in a single zip file).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ExportEntryRequestImageFormat Format { get; set; } = Laserfiche.Repository.Api.Client.ExportEntryRequestImageFormat.MultiPageTIFF;

        /// <summary>
        /// The quality level for JPEG compression when exporting images. The value must be between 0 and 100 (inclusive). The default value is 70.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("jPEGCompressionLevel", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int JPEGCompressionLevel { get; set; } = 70;

        /// <summary>
        /// Indicates if the annotations need to be included. The default value is true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeAnnotations", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeAnnotations { get; set; } = true;

        /// <summary>
        /// Indicates if the annotations on the image need to be converted to PDF annotations when exporting to PDF format. The default value is true. This option is only applicable when exporting to PDF format and IncludeAnnotations is true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("convertPdfAnnotations", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ConvertPdfAnnotations { get; set; } = true;

        /// <summary>
        /// The page prefix of the individual files, when exporting to multi-file format (e.g.zip). The value must have a length of atmost 10 characters and only valid characters that can be included in file names are allowed. The default value is ", Page ".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pagePrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PagePrefix { get; set; } = ", Page ";

        /// <summary>
        /// Indicates if redactions are included. The default value is true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeRedactions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeRedactions { get; set; } = true;

        /// <summary>
        /// The watermark element added to each image. No watermark will be added by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("watermark", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExportEntryRequestWatermark Watermark { get; set; }

    }

    /// <summary>
    /// Enumeration of formats when exporting the image part of an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExportEntryRequestImageFormat
    {

        [EnumMember(Value = @"MultiPageTIFF")]
        MultiPageTIFF = 0,

        [EnumMember(Value = @"SinglePageTIFF")]
        SinglePageTIFF = 1,

        [EnumMember(Value = @"PNG")]
        PNG = 2,

        [EnumMember(Value = @"PDF")]
        PDF = 3,

        [EnumMember(Value = @"JPEG")]
        JPEG = 4,

    }

    /// <summary>
    /// Represents the watermark added to the images when exporting an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportEntryRequestWatermark
    {
        /// <summary>
        /// The text of the watermark. The value must be a string with a length of atmost 100 characters and must not be all whitespace characters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Text { get; set; } = "";

        /// <summary>
        /// The position of the watermark. The default value is DeadCenter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WatermarkPosition Position { get; set; } = Laserfiche.Repository.Api.Client.WatermarkPosition.DeadCenter;

        /// <summary>
        /// The rotation angle of the watermark. The value must be between 0 and 360 (inclusive). The default value is 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rotationAngle", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int RotationAngle { get; set; } = 0;

        /// <summary>
        /// The percentage of the page that the watermark spans on. The value must be between 1 and 100 (inclusive). The default value is 50.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pageSpanPercentage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int PageSpanPercentage { get; set; } = 50;

    }

    /// <summary>
    /// An enumeration of possible positions on a page for watermarks.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum WatermarkPosition
    {

        [EnumMember(Value = @"TopLeft")]
        TopLeft = 0,

        [EnumMember(Value = @"TopCenter")]
        TopCenter = 1,

        [EnumMember(Value = @"TopRight")]
        TopRight = 2,

        [EnumMember(Value = @"MiddleLeft")]
        MiddleLeft = 3,

        [EnumMember(Value = @"DeadCenter")]
        DeadCenter = 4,

        [EnumMember(Value = @"MiddleRight")]
        MiddleRight = 5,

        [EnumMember(Value = @"BottomLeft")]
        BottomLeft = 6,

        [EnumMember(Value = @"BottomCenter")]
        BottomCenter = 7,

        [EnumMember(Value = @"BottomRight")]
        BottomRight = 8,

    }

    /// <summary>
    /// Represents the options when exporting the text part of an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportEntryRequestTextOptions
    {
        /// <summary>
        /// Indicates if redactions are included. The default value is true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeRedactions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeRedactions { get; set; } = true;

        /// <summary>
        /// The character that replaces the original character in a redacted text. The value must be a string of length 1 and must not be a whitespace character. The default value is 'X'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("redactionCharacter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RedactionCharacter { get; set; } = "X";

    }

    /// <summary>
    /// Request body for starting an asynchronous copy entry task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StartCopyEntryRequest
    {
        /// <summary>
        /// The name of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string Name { get; set; }

        /// <summary>
        /// Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoRename", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AutoRename { get; set; } = false;

        /// <summary>
        /// The source entry Id to copy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceId", Required = Newtonsoft.Json.Required.Always)]
        public int SourceId { get; set; }

        /// <summary>
        /// The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

    }

    /// <summary>
    /// Request body for starting an asynchronous delete entry task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StartDeleteEntryRequest
    {
        /// <summary>
        /// The reason id for this audit event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auditReasonId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AuditReasonId { get; set; }

        /// <summary>
        /// The comment for this audit event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auditReasonComment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuditReasonComment { get; set; }

    }

    /// <summary>
    /// Base type for all types which represent entry objects in a Laserfiche repository.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public abstract partial class Entry
    {
        /// <summary>
        /// The ID of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The name of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The ID of the parent entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ParentId { get; set; }

        /// <summary>
        /// The full path in the Laserfiche repository to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fullPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FullPath { get; set; }

        /// <summary>
        /// The path in the Laserfiche repository to the parent folder.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("folderPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FolderPath { get; set; }

        /// <summary>
        /// The name of the user that created this entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Creator { get; set; }

        /// <summary>
        /// The creation time of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("creationTime", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DateTimeOffset CreationTime { get; set; }

        /// <summary>
        /// The last modification time of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastModifiedTime", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DateTimeOffset LastModifiedTime { get; set; }

        /// <summary>
        /// The type of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entryType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntryType EntryType { get; set; }

        /// <summary>
        /// A boolean indicating if this entry is a container object; it can have other entries as children.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isContainer", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsContainer { get; set; }

        /// <summary>
        /// A boolean indicating if this entry is a leaf object; it cannot have other entries as children.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isLeaf", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsLeaf { get; set; }

        /// <summary>
        /// The name of the template assigned to this entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TemplateName { get; set; }

        /// <summary>
        /// The id of the template assigned to this entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int TemplateId { get; set; }

        /// <summary>
        /// The names of the fields assigned to the template assigned to this entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateFieldNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<string> TemplateFieldNames { get; set; }

        /// <summary>
        /// The name of the volume that this entry is associated with.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

        /// <summary>
        /// Row number assigned to this entry in the listing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rowNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RowNumber { get; set; }

        /// <summary>
        /// The fields assigned to this entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<Field> Fields { get; set; }

    }

    /// <summary>
    /// Enumeration of entry types.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntryType
    {

        [EnumMember(Value = @"Folder")]
        Folder = 0,

        [EnumMember(Value = @"RecordSeries")]
        RecordSeries = 1,

        [EnumMember(Value = @"Document")]
        Document = 2,

        [EnumMember(Value = @"Shortcut")]
        Shortcut = 3,

    }

    /// <summary>
    /// Represents a field set on an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Field
    {
        /// <summary>
        /// The name of the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The type of the field. The possible field types are listed below.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FieldType FieldType { get; set; }

        /// <summary>
        /// The ID of the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// A boolean indicating if the represented field supports multiple values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isMultiValue", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsMultiValue { get; set; }

        /// <summary>
        /// A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isRequired", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsRequired { get; set; }

        /// <summary>
        /// A boolean indicating if there are more field values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMoreValues", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool HasMoreValues { get; set; }

        /// <summary>
        /// The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groupId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GroupId { get; set; }

        /// <summary>
        /// The values assigned to the field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<string> Values { get; set; }

    }

    /// <summary>
    /// Represents a Laserfiche record series.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RecordSeries : Entry
    {

    }

    /// <summary>
    /// Represents a document in a Laserfiche repository.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Document : Entry
    {
        /// <summary>
        /// The size of the electronic document attached to the represented document, if there is one, in bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("electronicDocumentSize", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long ElectronicDocumentSize { get; set; }

        /// <summary>
        /// The extension for the document.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extension", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Extension { get; set; }

        /// <summary>
        /// A boolean indicating if there is an electronic document attached to the represented document.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isElectronicDocument", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsElectronicDocument { get; set; }

        /// <summary>
        /// A boolean indicating if the represented document is a record.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isRecord", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsRecord { get; set; }

        /// <summary>
        /// The MIME type of the electronic document.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mimeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MimeType { get; set; }

        /// <summary>
        /// The page count of the represented document.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pageCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int PageCount { get; set; }

        /// <summary>
        /// A boolean indicating if the represented document is checked out.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isCheckedOut", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsCheckedOut { get; set; }

        /// <summary>
        /// A boolean indicating if the represented document is under version control.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isUnderVersionControl", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsUnderVersionControl { get; set; }

    }

    /// <summary>
    /// Represents an entry shortcut in a Laserfiche repository.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Shortcut : Entry
    {
        /// <summary>
        /// The entry ID of the shortcut target.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int TargetId { get; set; }

        /// <summary>
        /// The extension of the shortcut target.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extension", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Extension { get; set; }

        /// <summary>
        /// The entry type of the shortcut target.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntryType TargetType { get; set; }

    }

    /// <summary>
    /// Represents a folder (standard or record folder) in a Laserfiche repository.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Folder : Entry
    {
        /// <summary>
        /// A boolean indicating if the folder that this instance represents is known to be a record folder.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isRecordFolder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsRecordFolder { get; set; }

        /// <summary>
        /// A boolean indicating if the folder that this instance represents is known to directly or indirectly under a record series in the repository.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isUnderRecordSeries", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsUnderRecordSeries { get; set; }

    }

    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public abstract partial class IHeaderDictionary
    {
        [Newtonsoft.Json.JsonProperty("Item", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Item { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ContentLength { get; set; }

        [Newtonsoft.Json.JsonProperty("Accept", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Accept { get; set; }

        [Newtonsoft.Json.JsonProperty("AcceptCharset", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AcceptCharset { get; set; }

        [Newtonsoft.Json.JsonProperty("AcceptEncoding", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AcceptEncoding { get; set; }

        [Newtonsoft.Json.JsonProperty("AcceptLanguage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AcceptLanguage { get; set; }

        [Newtonsoft.Json.JsonProperty("AcceptRanges", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AcceptRanges { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlAllowCredentials", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlAllowCredentials { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlAllowHeaders", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlAllowHeaders { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlAllowMethods", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlAllowMethods { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlAllowOrigin", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlAllowOrigin { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlExposeHeaders", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlExposeHeaders { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlMaxAge", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlMaxAge { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlRequestHeaders", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlRequestHeaders { get; set; }

        [Newtonsoft.Json.JsonProperty("AccessControlRequestMethod", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AccessControlRequestMethod { get; set; }

        [Newtonsoft.Json.JsonProperty("Age", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Age { get; set; }

        [Newtonsoft.Json.JsonProperty("Allow", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Allow { get; set; }

        [Newtonsoft.Json.JsonProperty("AltSvc", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> AltSvc { get; set; }

        [Newtonsoft.Json.JsonProperty("Authorization", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Authorization { get; set; }

        [Newtonsoft.Json.JsonProperty("Baggage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Baggage { get; set; }

        [Newtonsoft.Json.JsonProperty("CacheControl", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> CacheControl { get; set; }

        [Newtonsoft.Json.JsonProperty("Connection", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Connection { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentDisposition", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentDisposition { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentEncoding", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentEncoding { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentLanguage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentLanguage { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentLocation", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentLocation { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentMD5", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentMD5 { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentRange", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentRange { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentSecurityPolicy", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentSecurityPolicy { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentSecurityPolicyReportOnly", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentSecurityPolicyReportOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("ContentType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ContentType { get; set; }

        [Newtonsoft.Json.JsonProperty("CorrelationContext", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> CorrelationContext { get; set; }

        [Newtonsoft.Json.JsonProperty("Cookie", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Cookie { get; set; }

        [Newtonsoft.Json.JsonProperty("Date", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Date { get; set; }

        [Newtonsoft.Json.JsonProperty("ETag", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ETag { get; set; }

        [Newtonsoft.Json.JsonProperty("Expires", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Expires { get; set; }

        [Newtonsoft.Json.JsonProperty("Expect", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Expect { get; set; }

        [Newtonsoft.Json.JsonProperty("From", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> From { get; set; }

        [Newtonsoft.Json.JsonProperty("GrpcAcceptEncoding", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> GrpcAcceptEncoding { get; set; }

        [Newtonsoft.Json.JsonProperty("GrpcEncoding", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> GrpcEncoding { get; set; }

        [Newtonsoft.Json.JsonProperty("GrpcMessage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> GrpcMessage { get; set; }

        [Newtonsoft.Json.JsonProperty("GrpcStatus", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> GrpcStatus { get; set; }

        [Newtonsoft.Json.JsonProperty("GrpcTimeout", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> GrpcTimeout { get; set; }

        [Newtonsoft.Json.JsonProperty("Host", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Host { get; set; }

        [Newtonsoft.Json.JsonProperty("KeepAlive", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> KeepAlive { get; set; }

        [Newtonsoft.Json.JsonProperty("IfMatch", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> IfMatch { get; set; }

        [Newtonsoft.Json.JsonProperty("IfModifiedSince", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> IfModifiedSince { get; set; }

        [Newtonsoft.Json.JsonProperty("IfNoneMatch", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> IfNoneMatch { get; set; }

        [Newtonsoft.Json.JsonProperty("IfRange", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> IfRange { get; set; }

        [Newtonsoft.Json.JsonProperty("IfUnmodifiedSince", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> IfUnmodifiedSince { get; set; }

        [Newtonsoft.Json.JsonProperty("LastModified", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> LastModified { get; set; }

        [Newtonsoft.Json.JsonProperty("Link", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Link { get; set; }

        [Newtonsoft.Json.JsonProperty("Location", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Location { get; set; }

        [Newtonsoft.Json.JsonProperty("MaxForwards", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> MaxForwards { get; set; }

        [Newtonsoft.Json.JsonProperty("Origin", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Origin { get; set; }

        [Newtonsoft.Json.JsonProperty("Pragma", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Pragma { get; set; }

        [Newtonsoft.Json.JsonProperty("ProxyAuthenticate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ProxyAuthenticate { get; set; }

        [Newtonsoft.Json.JsonProperty("ProxyAuthorization", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ProxyAuthorization { get; set; }

        [Newtonsoft.Json.JsonProperty("ProxyConnection", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> ProxyConnection { get; set; }

        [Newtonsoft.Json.JsonProperty("Range", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Range { get; set; }

        [Newtonsoft.Json.JsonProperty("Referer", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Referer { get; set; }

        [Newtonsoft.Json.JsonProperty("RetryAfter", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> RetryAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("RequestId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> RequestId { get; set; }

        [Newtonsoft.Json.JsonProperty("SecWebSocketAccept", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> SecWebSocketAccept { get; set; }

        [Newtonsoft.Json.JsonProperty("SecWebSocketKey", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> SecWebSocketKey { get; set; }

        [Newtonsoft.Json.JsonProperty("SecWebSocketProtocol", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> SecWebSocketProtocol { get; set; }

        [Newtonsoft.Json.JsonProperty("SecWebSocketVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> SecWebSocketVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("SecWebSocketExtensions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> SecWebSocketExtensions { get; set; }

        [Newtonsoft.Json.JsonProperty("Server", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Server { get; set; }

        [Newtonsoft.Json.JsonProperty("SetCookie", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> SetCookie { get; set; }

        [Newtonsoft.Json.JsonProperty("StrictTransportSecurity", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> StrictTransportSecurity { get; set; }

        [Newtonsoft.Json.JsonProperty("TE", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> TE { get; set; }

        [Newtonsoft.Json.JsonProperty("Trailer", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Trailer { get; set; }

        [Newtonsoft.Json.JsonProperty("TransferEncoding", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> TransferEncoding { get; set; }

        [Newtonsoft.Json.JsonProperty("Translate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Translate { get; set; }

        [Newtonsoft.Json.JsonProperty("TraceParent", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> TraceParent { get; set; }

        [Newtonsoft.Json.JsonProperty("TraceState", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> TraceState { get; set; }

        [Newtonsoft.Json.JsonProperty("Upgrade", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Upgrade { get; set; }

        [Newtonsoft.Json.JsonProperty("UpgradeInsecureRequests", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> UpgradeInsecureRequests { get; set; }

        [Newtonsoft.Json.JsonProperty("UserAgent", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> UserAgent { get; set; }

        [Newtonsoft.Json.JsonProperty("Vary", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Vary { get; set; }

        [Newtonsoft.Json.JsonProperty("Via", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Via { get; set; }

        [Newtonsoft.Json.JsonProperty("Warning", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> Warning { get; set; }

        [Newtonsoft.Json.JsonProperty("WebSocketSubProtocols", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> WebSocketSubProtocols { get; set; }

        [Newtonsoft.Json.JsonProperty("WWWAuthenticate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> WWWAuthenticate { get; set; }

        [Newtonsoft.Json.JsonProperty("XContentTypeOptions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> XContentTypeOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("XFrameOptions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> XFrameOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("XPoweredBy", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> XPoweredBy { get; set; }

        [Newtonsoft.Json.JsonProperty("XRequestedWith", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> XRequestedWith { get; set; }

        [Newtonsoft.Json.JsonProperty("XUACompatible", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> XUACompatible { get; set; }

        [Newtonsoft.Json.JsonProperty("XXSSProtection", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<object> XXSSProtection { get; set; }

    }

    /// <summary>
    /// Request body for importing an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImportEntryRequest
    {
        /// <summary>
        /// The name for the imported entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoRename", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AutoRename { get; set; } = false;

        /// <summary>
        /// The options applied when importing a PDF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pdfOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ImportEntryRequestPdfOptions PdfOptions { get; set; }

        /// <summary>
        /// Indicates if the document should be imported as an electronic document (true) or as image pages (false). The default value is false. This option is only applicable when importing the following document types: txt, tif, tiff, bmp, pcx, jpg, jpeg, gif, png.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("importAsElectronicDocument", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ImportAsElectronicDocument { get; set; } = false;

        /// <summary>
        /// The metadata that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ImportEntryRequestMetadata Metadata { get; set; }

        /// <summary>
        /// The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

    }

    /// <summary>
    /// Response containing a link to download the exported entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportEntryResponse
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// Request body for exporting an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportEntryRequest
    {
        /// <summary>
        /// The reason id for this audit event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auditReasonId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int AuditReasonId { get; set; }

        /// <summary>
        /// The comment for this audit event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auditReasonComment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuditReasonComment { get; set; } = "";

        /// <summary>
        /// The part of the document to export. Options include: Image, Text, Edoc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("part", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ExportEntryRequestPart Part { get; set; }

        /// <summary>
        /// The options applied when exporting as Image.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imageOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExportEntryRequestImageOptions ImageOptions { get; set; }

        /// <summary>
        /// The options applied when exporting as Text.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("textOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExportEntryRequestTextOptions TextOptions { get; set; }

    }

    /// <summary>
    /// Response containing an entry or ancestor entry found by entry path.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetEntryByPathResponse
    {
        /// <summary>
        /// The entry found by path. This property is set if entry is found.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Entry Entry { get; set; }

        /// <summary>
        /// The closest entry ancestor. This property is set if entry is not found and fallbackToClosestAncestor is set to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ancestorEntry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Entry AncestorEntry { get; set; }

    }

    /// <summary>
    /// Request body for updating an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateEntryRequest
    {
        /// <summary>
        /// The ID of the parent entry that the entry will be moved to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ParentId { get; set; }

        /// <summary>
        /// The name that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoRename", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AutoRename { get; set; } = false;

    }

    /// <summary>
    /// Response containing a collection of Entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntryCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<Entry> Value { get; set; }

    }

    /// <summary>
    /// Response containing a collection of Field.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FieldCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<Field> Value { get; set; }

    }

    /// <summary>
    /// Request body for assigning fields to an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SetFieldsRequest
    {
        /// <summary>
        /// The fields that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<FieldToUpdate> Fields { get; set; }

    }

    /// <summary>
    /// Response containing a collection of Tag.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<Tag> Value { get; set; }

    }

    /// <summary>
    /// Represents a tag set on an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Tag
    {
        /// <summary>
        /// The ID of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The name of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The localized name of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// The description of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isSecure", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsSecure { get; set; }

        /// <summary>
        /// The watermark properties associated with the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("watermark", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TagDefinitionWatermark Watermark { get; set; }

    }

    /// <summary>
    /// Represents a watermark associated with a tag defintion.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagDefinitionWatermark
    {
        /// <summary>
        /// The watermark text associated with the tag defintion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// The percentage of the page that the watermark associated with the tag definition spans on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pageSpanPercentage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int PageSpanPercentage { get; set; }

        /// <summary>
        /// The position of the watermark on the page.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WatermarkPosition Position { get; set; }

        /// <summary>
        /// The rotation angle, in degrees, of the watermark associated with the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rotationAngle", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int RotationAngle { get; set; }

        /// <summary>
        /// A boolean indicating whether or not the watermark associated with the tag is mandatory.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isMandatory", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsMandatory { get; set; }

        /// <summary>
        /// The opacity of the watermark associated with the tag definition. Valid value ranges from 0 to 100, with -1 as the default values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("opacity", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Opacity { get; set; }

    }

    /// <summary>
    /// Request body for assigning tags to an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SetTagsRequest
    {
        /// <summary>
        /// The tag names to assign to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<string> Tags { get; set; }

    }

    /// <summary>
    /// Response containing a collection of Link.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LinkCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<Link> Value { get; set; }

    }

    /// <summary>
    /// Represents a link between a source entry and a target entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Link
    {
        /// <summary>
        /// The ID of the represented link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The description for the represented link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The ID of the source entry of the represented link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int SourceId { get; set; }

        /// <summary>
        /// The full path to the source entry of the represented link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceFullPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceFullPath { get; set; }

        /// <summary>
        /// The label for the source entry in the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceLabel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceLabel { get; set; }

        /// <summary>
        /// The navigation link to the source entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceLink { get; set; }

        /// <summary>
        /// The ID of the target entry of the represented link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int TargetId { get; set; }

        /// <summary>
        /// The full path to the target entry of the represented link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetFullPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetFullPath { get; set; }

        /// <summary>
        /// The label for the target entry in the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetLabel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetLabel { get; set; }

        /// <summary>
        /// The navigation link to the target entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetLink { get; set; }

        /// <summary>
        /// The ID of the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkDefinitionId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int LinkDefinitionId { get; set; }

        /// <summary>
        /// The description of the link definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkDefinitionDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkDefinitionDescription { get; set; }

        /// <summary>
        /// The custom properties for the represented link.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IDictionary<string, string> CustomProperties { get; set; }

    }

    /// <summary>
    /// Request body for assigning links to an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SetLinksRequest
    {
        /// <summary>
        /// The links that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<LinkToUpdate> Links { get; set; }

    }

    /// <summary>
    /// Request body for copying an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CopyEntryRequest
    {
        /// <summary>
        /// The name of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string Name { get; set; }

        /// <summary>
        /// Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoRename", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AutoRename { get; set; } = false;

        /// <summary>
        /// The source entry Id to copy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceId", Required = Newtonsoft.Json.Required.Always)]
        public int SourceId { get; set; }

        /// <summary>
        /// The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

    }

    /// <summary>
    /// Request body for creating an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateEntryRequest
    {
        /// <summary>
        /// The name of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string Name { get; set; }

        /// <summary>
        /// Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoRename", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool AutoRename { get; set; } = false;

        /// <summary>
        /// The type of the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entryType", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreateEntryRequestEntryType EntryType { get; set; }

        /// <summary>
        /// The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int TargetId { get; set; }

        /// <summary>
        /// The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

    }

    /// <summary>
    /// Enumeration of entry types for CreateEntry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CreateEntryRequestEntryType
    {

        [EnumMember(Value = @"Folder")]
        Folder = 0,

        [EnumMember(Value = @"Shortcut")]
        Shortcut = 1,

    }

    /// <summary>
    /// Request body for listing dynamic field values for an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ListDynamicFieldValuesRequest
    {
        /// <summary>
        /// The template id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateId", Required = Newtonsoft.Json.Required.Always)]
        public int TemplateId { get; set; }

        /// <summary>
        /// The dynamic fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldValues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IDictionary<string, string> FieldValues { get; set; }

    }

    /// <summary>
    /// Request body for assigning a template and template fields to an entry.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SetTemplateRequest
    {
        /// <summary>
        /// The template that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateName", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string TemplateName { get; set; }

        /// <summary>
        /// The template fields that will be assigned to the entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<FieldToUpdate> Fields { get; set; }

    }

    /// <summary>
    /// Response containing a collection of Repository.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RepositoryCollectionResponse
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<Repository> Value { get; set; }

    }

    /// <summary>
    /// Represents a Laserfiche repository.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Repository
    {
        /// <summary>
        /// The repository id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The repository name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The corresponding repository Web Client url.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("webClientUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WebClientUrl { get; set; }

    }

    /// <summary>
    /// Request body for starting an asynchronous search entry task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StartSearchEntryRequest
    {
        /// <summary>
        /// The search command to run. The search command should follow the Laserfiche search syntax. https://doc.laserfiche.com/laserfiche.documentation/en-us/Default.htm#Search_Syntax.htm
        /// </summary>
        [Newtonsoft.Json.JsonProperty("searchCommand", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string SearchCommand { get; set; }

        /// <summary>
        /// Fuzzy type (None, Percentage, or NumberOfLetters).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fuzzyType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FuzzyType FuzzyType { get; set; }

        /// <summary>
        /// Fuzzy factor (percentage as int or int value).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fuzzyFactor", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int FuzzyFactor { get; set; }

    }

    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FuzzyType
    {

        [EnumMember(Value = @"None")]
        None = 0,

        [EnumMember(Value = @"Percentage")]
        Percentage = 1,

        [EnumMember(Value = @"NumberOfLetters")]
        NumberOfLetters = 2,

    }

    /// <summary>
    /// Response containing a collection of SearchContextHit.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchContextHitCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<SearchContextHit> Value { get; set; }

    }

    /// <summary>
    /// Represents a context hit for a search result.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchContextHit
    {
        /// <summary>
        /// The type of context hit this instance represents.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hitType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HitType HitType { get; set; }

        /// <summary>
        /// A boolean indicating if this context hit occurs on an annotation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isAnnotationHit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsAnnotationHit { get; set; }

        /// <summary>
        /// The ID of the annotation that the context hit is in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("annotationId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int AnnotationId { get; set; }

        /// <summary>
        /// The page number in the document of the search hit's context.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pageNumber", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int PageNumber { get; set; }

        /// <summary>
        /// The offset from the beginning of the page of the starting character of the search hit's context line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pageOffset", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int PageOffset { get; set; }

        /// <summary>
        /// The line of context for the search hit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Context { get; set; }

        /// <summary>
        /// The character offset from the beginning of the context line of the start of the first highlight.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("highlight1Offset", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Highlight1Offset { get; set; }

        /// <summary>
        /// The length of the first highlight in characters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("highlight1Length", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Highlight1Length { get; set; }

        /// <summary>
        /// The character offset from the beginning of the context line of the start of the second highlight.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("highlight2Offset", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Highlight2Offset { get; set; }

        /// <summary>
        /// The length of the second highlight in characters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("highlight2Length", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Highlight2Length { get; set; }

        /// <summary>
        /// The number of words in the context hit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hitWidth", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int HitWidth { get; set; }

        /// <summary>
        /// The number of hits in the electronic document.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edocHitCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int EdocHitCount { get; set; }

        /// <summary>
        /// The number of hits in the template.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldHitCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int FieldHitCount { get; set; }

        /// <summary>
        /// The name of a template field containing the hit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldName { get; set; }

        /// <summary>
        /// The hit number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hitNumber", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int HitNumber { get; set; }

    }

    /// <summary>
    /// The type of context hit.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HitType
    {

        [EnumMember(Value = @"PageContent")]
        PageContent = 0,

        [EnumMember(Value = @"Note")]
        Note = 1,

        [EnumMember(Value = @"Callout")]
        Callout = 2,

        [EnumMember(Value = @"TextBox")]
        TextBox = 3,

        [EnumMember(Value = @"Edoc")]
        Edoc = 4,

        [EnumMember(Value = @"Prop")]
        Prop = 5,

        [EnumMember(Value = @"Name")]
        Name = 6,

        [EnumMember(Value = @"Extension")]
        Extension = 7,

        [EnumMember(Value = @"VersionGroupNote")]
        VersionGroupNote = 8,

        [EnumMember(Value = @"VersionComment")]
        VersionComment = 9,

        [EnumMember(Value = @"Field")]
        Field = 10,

        [EnumMember(Value = @"SignatureComment")]
        SignatureComment = 11,

        [EnumMember(Value = @"CertificateSubject")]
        CertificateSubject = 12,

        [EnumMember(Value = @"TagComment")]
        TagComment = 13,

        [EnumMember(Value = @"AnnotationComment")]
        AnnotationComment = 14,

        [EnumMember(Value = @"Attachment")]
        Attachment = 15,

    }

    /// <summary>
    /// Request body for searching entries.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchEntryRequest
    {
        /// <summary>
        /// The search command to run. The search command should follow the Laserfiche search syntax. https://doc.laserfiche.com/laserfiche.documentation/en-us/Default.htm#Search_Syntax.htm
        /// </summary>
        [Newtonsoft.Json.JsonProperty("searchCommand", Required = Newtonsoft.Json.Required.Always)]
        [ComponentModel.DataAnnotations.Required]
        public string SearchCommand { get; set; }

    }

    /// <summary>
    /// Response containing a collection of TagDefinition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagDefinitionCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<TagDefinition> Value { get; set; }

    }

    /// <summary>
    /// Represents an entry tag definition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagDefinition
    {
        /// <summary>
        /// The ID of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The name of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The localized name of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// The description of the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isSecure", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsSecure { get; set; }

        /// <summary>
        /// The watermark properties associated with the tag definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("watermark", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TagDefinitionWatermark Watermark { get; set; }

    }

    /// <summary>
    /// Response containing a collection of TaskProgress.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TaskCollectionResponse
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<TaskProgress> Value { get; set; }

    }

    /// <summary>
    /// Represents the progress of a long operation task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TaskProgress
    {
        /// <summary>
        /// The task ID of the task associated with this TaskProgress.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The type of the task associated with this TaskProgress.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("taskType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TaskType TaskType { get; set; }

        /// <summary>
        /// Determines what percentage of the execution of the associated task is completed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("percentComplete", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int PercentComplete { get; set; }

        /// <summary>
        /// The status of the task associated with this TaskProgress.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TaskStatus Status { get; set; }

        /// <summary>
        /// The list of errors occurred during the execution of the associated task.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<ProblemDetails> Errors { get; set; }

        /// <summary>
        /// The result of the execution of the associated task.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TaskResult Result { get; set; }

        /// <summary>
        /// The time representing when the associated task's execution started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DateTimeOffset StartTime { get; set; }

        /// <summary>
        /// The time representing when the associated task's status last changed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastUpdateTime", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DateTimeOffset LastUpdateTime { get; set; }

    }

    /// <summary>
    /// An enumeration of possible types for a long operation task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TaskType
    {

        [EnumMember(Value = @"CopyEntry")]
        CopyEntry = 0,

        [EnumMember(Value = @"DeleteEntry")]
        DeleteEntry = 1,

        [EnumMember(Value = @"ExportEntry")]
        ExportEntry = 2,

        [EnumMember(Value = @"ImportUploadedParts")]
        ImportUploadedParts = 3,

        [EnumMember(Value = @"SearchEntry")]
        SearchEntry = 4,

    }

    /// <summary>
    /// An enumeration of possible statuses for a long operation task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TaskStatus
    {

        [EnumMember(Value = @"NotStarted")]
        NotStarted = 0,

        [EnumMember(Value = @"InProgress")]
        InProgress = 1,

        [EnumMember(Value = @"Completed")]
        Completed = 2,

        [EnumMember(Value = @"Failed")]
        Failed = 3,

        [EnumMember(Value = @"Cancelled")]
        Cancelled = 4,

    }

    /// <summary>
    /// Represents the result of a long operation task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TaskResult
    {
        /// <summary>
        /// The ID of the entry which is affected (e.g. created or modified) by the execution of the associated task.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entryId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int EntryId { get; set; }

        /// <summary>
        /// The URI which can be used (via api call) to access the result(s) of the associated task.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uri { get; set; }

    }

    /// <summary>
    /// Response containing a collection of CancelTaskResult.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelTasksResponse
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<CancelTaskResult> Value { get; set; }

    }

    /// <summary>
    /// Represents the result of cancelling a long operation task.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelTaskResult
    {
        /// <summary>
        /// The ID of the task which has been subject to cancellation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The type of the task which has been subject to cancellation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("taskType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TaskType TaskType { get; set; }

        /// <summary>
        /// Indicates if the request to cancel the task has been received.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Result { get; set; }

    }

    /// <summary>
    /// Response containing a collection of TemplateDefinition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TemplateDefinitionCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<TemplateDefinition> Value { get; set; }

    }

    /// <summary>
    /// Represents a template definition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TemplateDefinition
    {
        /// <summary>
        /// The ID of the template definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The name of the template definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The localized name of the template definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// The description of the template definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The color assigned to the template definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LFColor Color { get; set; }

        /// <summary>
        /// The number of field definitions assigned to the template definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int FieldCount { get; set; }

    }

    /// <summary>
    /// Represents an RGB color value with alpha channel.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LFColor
    {
        /// <summary>
        /// The alpha channel component, from 0-255.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("a", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte A { get; set; }

        /// <summary>
        /// The red channel component, from 0-255.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("r", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte R { get; set; }

        /// <summary>
        /// The green channel component, from 0-255.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("g", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte G { get; set; }

        /// <summary>
        /// The blue channel component from 0-255.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("b", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte B { get; set; }

    }

    /// <summary>
    /// Response containing a collection of TemplateFieldDefinition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TemplateFieldDefinitionCollectionResponse
    {
        /// <summary>
        /// A URL to retrieve the next page of the requested collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OdataNextLink { get; set; }

        /// <summary>
        /// The total count of items within a collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("@odata.count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? OdataCount { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<TemplateFieldDefinition> Value { get; set; }

    }

    /// <summary>
    /// Represents a template field definition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TemplateFieldDefinition : FieldDefinition
    {
        /// <summary>
        /// A form logic rule associated with a Laserfiche template and field definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Rule Rule { get; set; }

        /// <summary>
        /// The group id of the field in the template.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groupId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int GroupId { get; set; }

        /// <summary>
        /// The name of field group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groupName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupName { get; set; }

    }

    /// <summary>
    /// Represents a form logic rule associated with a Laserfiche template and field definition.
    /// </summary>
    [GeneratedCode("NJsonSchema", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Rule
    {
        /// <summary>
        /// The IDs of the parent fields in the template according to the form logic rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ancestors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IList<int> Ancestors { get; set; }

    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(Stream data)
            : this (data, null, null)
        {
        }

        public FileParameter(Stream data, string fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }


    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HttpResponseHead
    {
        public int StatusCode { get; private set; }

        public IReadOnlyDictionary<string, IEnumerable<string>> Headers { get; private set; }

        public HttpResponseHead(int statusCode, IReadOnlyDictionary<string, IEnumerable<string>> headers)
        {
            StatusCode = statusCode;
            Headers = headers;
        }
    }

    [GeneratedCode("NSwag", "13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HttpResponseHead<TResult> : HttpResponseHead
    {
        public TResult Result { get; private set; }

        public HttpResponseHead(int statusCode, IReadOnlyDictionary<string, IEnumerable<string>> headers, TResult result)
            : base(statusCode, headers)
        {
            Result = result;
        }
    }



}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603

