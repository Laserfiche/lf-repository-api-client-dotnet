{
  "x-generator": "NSwag v13.14.8.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v13.0.0.0))",
  "openapi": "3.0.0",
  "info": {
    "title": "Laserfiche Repository API",
    "description": "Welcome to the Laserfiche API Swagger Playground. You can try out any of our API calls against your live Laserfiche Cloud account. Visit the developer center for more details: <a href=\"https://developer.laserfiche.com\">https://developer.laserfiche.com</a><p>Visit the changelog for the list of changes: <a href=\"/repository/v2/changelog\">/repository/v2/changelog</a></p><p><strong>Build# : </strong>cd6b166ea01a3650124d8a563b445058494f881e_.20230901.2</p>",
    "version": "2"
  },
  "servers": [
    {
      "url": "https://api.laserfiche.com/repository"
    }
  ],
  "paths": {
    "/v2/Repositories/{repositoryId}/Attributes": {
      "get": {
        "tags": [
          "Attributes"
        ],
        "summary": "Returns the attribute key value pairs associated with the authenticated user.",
        "description": "- Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the \"Everyone\" group.\n- Attribute keys can be used with subsequent calls to get specific attribute values.\n- Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the \"Everyone\" group. Note when this is true, the response does not include both the \"Everyone\" groups attribute and the currently authenticated user, but only the \"Everyone\" groups.\n- Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListAttributes",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "everyone",
            "in": "query",
            "description": "Indicates if attributes associated with the \"Everyone\" group or the currently authenticated user is returned. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of attributes associated with the authenticated user.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AttributeCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Attributes/{attributeKey}": {
      "get": {
        "tags": [
          "Attributes"
        ],
        "summary": "Returns an attribute object associated with the authenticated user.",
        "description": "- Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within \"Everyone\" group.\n- Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.\n- Required OAuth scope: repository.Read",
        "operationId": "GetAttribute",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "attributeKey",
            "in": "path",
            "required": true,
            "description": "The requested attribute key.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "everyone",
            "in": "query",
            "description": "Indicates if attributes associated with the \"Everyone\" group or the currently authenticated user is returned. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "A single attribute associated with the authenticated user.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Attribute"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested attribute key not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/AuditReasons": {
      "get": {
        "tags": [
          "AuditReasons"
        ],
        "summary": "Returns the audit reasons associated with the authenticated user.",
        "description": "- Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included.\n- Only includes audit reasons associated with available API functionalities, like delete entry and export document.\n- If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.\n- Required OAuth scope: repository.Read",
        "operationId": "ListAuditReasons",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 6
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 8
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of audit reasons.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditReasonCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/FieldDefinitions/{fieldId}": {
      "get": {
        "tags": [
          "FieldDefinitions"
        ],
        "summary": "Returns a single field definition object.",
        "description": "- Returns a single field definition associated with the specified ID. \n- Useful when a route provides a minimal amount of details and more information about the specific field definition is needed.\n- Allowed OData query options: Select\n- Required OAuth scope: repository.Read",
        "operationId": "GetFieldDefinition",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "fieldId",
            "in": "path",
            "required": true,
            "description": "The requested field definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "responses": {
          "200": {
            "description": "A single field definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FieldDefinition"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested field definition id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/FieldDefinitions": {
      "get": {
        "tags": [
          "FieldDefinitions"
        ],
        "summary": "Returns the paged listing of the field definitions available in a repository.",
        "description": "- Returns a paged listing of field definitions available in the specified repository.\n- Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListFieldDefinitions",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of field definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FieldDefinitionCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/LinkDefinitions": {
      "get": {
        "tags": [
          "LinkDefinitions"
        ],
        "summary": "Returns the link definitions associated with a repository.",
        "description": "- Returns the link definitions in the repository.\n- Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListLinkDefinitions",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 6
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 8
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of link definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LinkDefinitionCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/LinkDefinitions/{linkDefinitionId}": {
      "get": {
        "tags": [
          "LinkDefinitions"
        ],
        "summary": "Returns a single link definition object.",
        "description": "- Returns a single link definition associated with the specified ID.\n- Provide a link definition ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed.\n- Allowed OData query options: Select\n- Required OAuth scope: repository.Read",
        "operationId": "GetLinkDefinition",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "linkDefinitionId",
            "in": "path",
            "required": true,
            "description": "The requested link definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "A single link definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LinkDefinition"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested link definition ID not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/CreateMultipartUploadUrls": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Requests Upload URLs to upload a large file in chunks.",
        "description": "- Requests Upload URLs to upload a large file in chunks.\n- Returns an UploadId and an array of URLs to which the file chunks should be written in the same order.\n- To request a new batch of Upload URLs for the same file, set the value of UploadId to the one returned when the first batch of Upload URLs was requested. For requesting the first batch of Upload URLs, leave UploadId empty or null.\n- Example: if a file is going to be uploaded in 10 chunks, the 10 Upload URLs can be retrieved by two successive calls to this api, each call requesting 5 Upload URLs. For this, the first call should have StartingPartNumber=1 and NumberOfParts=5, and the second call should have StartingPartNumber=6 and NumberOfParts=5, along with UploadId returned in the first call.\n- Each Upload URL expires after 15 minutes.\n- Each file chunk written to an Upload URL should be at least 5 MB and at most 5 GB. There is no minimum size limit for the last chunk.\n- The value of NumberOfParts must be in the range [1, 100], meaning that in each call to this api, a maximum of 100 Upload URLs can be requested. \n- The total number of Upload URLs for a single file is 1000, which means (StartingPartNumber + NumberOfParts) should be less than or equal to 1001.\n- Required OAuth scope: repository.Write",
        "operationId": "CreateMultipartUploadUrls",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateMultipartUploadUrlsRequest"
              },
              "examples": {
                "1": {
                  "summary": "Request the first batch of URLs",
                  "description": "The body of the CreateMultipartUploadUrls request for requesting a batch of 5 URLs, as the first batch.",
                  "value": {
                    "startingPartNumber": 1,
                    "numberOfParts": 5,
                    "fileName": "Sample.pdf",
                    "mimeType": "application/pdf"
                  }
                },
                "2": {
                  "summary": "Request the second batch of URLs",
                  "description": "The body of the CreateMultipartUploadUrls request for requesting a batch of 5 URLs, as the second batch. The value of UploadId should be the same as the one received in the response of the first request. Any value sent for FileName or MimeType is ignored.",
                  "value": {
                    "uploadId": "VXBsb2FkSWRGcm9tRmlyc3RSZXF1ZXN0",
                    "startingPartNumber": 6,
                    "numberOfParts": 5
                  }
                },
                "3": {
                  "summary": "Request the third batch of URLs",
                  "description": "The body of the CreateMultipartUploadUrls request for requesting a batch of 5 URLs, as the third batch. The value of UploadId should be the same as the one received in the response of the first request. Any value sent for FileName or MimeType is ignored.",
                  "value": {
                    "uploadId": "VXBsb2FkSWRGcm9tRmlyc3RSZXF1ZXN0",
                    "startingPartNumber": 11,
                    "numberOfParts": 5
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 2
        },
        "responses": {
          "200": {
            "description": "A response containing an upload id and an array of upload URLs.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateMultipartUploadUrlsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested repository not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/ImportUploadedParts": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Starts an asynchronous import task to import a document into a folder.",
        "description": "- Imports a new file in the specified folder. The file should be already written (in chunks) to the upload URLs obtained by calling the Upload api.\n- This route does not support partial success.\n- Required OAuth scope: repository.Write",
        "operationId": "StartImportUploadedParts",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The entry ID of the folder that the document will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartImportUploadedPartsRequest"
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "202": {
            "description": "A long operation task id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartTaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested repository not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "Import operation failed due to an internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/ExportAsync": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Starts an asynchronous export task to export an entry.",
        "description": "- Starts an asynchronous export operation to export an entry.\n- If successful, it returns a taskId which can be used to check the status of the export operation or download the export result, otherwise, it returns an error.\n- Required OAuth scope: repository.Read",
        "operationId": "StartExportEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The ID of entry to export.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "pageRange",
            "in": "query",
            "description": "A comma-separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when part=Edoc.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartExportEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Export the image part of a Laserfiche Document",
                  "description": "The body of the export request includes:<br /><ol><li>The audit event information to associate with the export operation.</li><li><strong>part</strong>: the part of the document to export. Options include: <strong>Image, Text, Edoc</strong>.</li><li><strong>imageOptions</strong>: The options applied when exporting as Image.<ul><li><strong>format:</strong> the image format to export as. Options include: <strong>MultiPageTIFF, SinglePageTIFF, PNG, PDF, JPEG</strong>. The default value is MultiPageTIFF. MultiPageTIFF format is a single multi-page TIFF file. SinglePageTIFF format is multiple single-page TIFF files (in a single zip file).</li><li><strong>jpegCompressionLevel:</strong> the quality level for JPEG compression when exporting images. The value must be between 0 and 100 (inclusive). The default value is 70.</li><li><strong>includeAnnotations:</strong> indicates if the annotations need to be included. The default value is true.</li><li><strong>convertPdfAnnotations</strong>: indicates if the annotations on the image need to be converted to PDF annotations when exporting to PDF format. The default value is true. This option is only applicable when exporting to PDF format and includeAnnotations is true.</li><li><strong>pagePrefix</strong>: the page prefix of the individual files, when exporting to multi-file format (e.g.zip). The value must have a length of atmost 10 characters and only valid characters that can be included in file names are allowed. The default value is \", Page \".</li><li><strong>includeRedactions</strong>: indicates if redactions are included. The default value is true.</li><li><strong>watermark</strong>: the watermark element added to the image. This includes the following properties: <ul><li><strong>text</strong>: the text of the watermark. The value must be a string with a length of atmost 100 characters and must not be all whitespace characters. Using emojis in the text is not supported.</li><li><strong>position</strong>: the position of the watermark. The default value is DeadCenter. Assuming that the page is divided into a 3x3 grid, then position can be specified using the following values: <ul><li>TopLeft, TopCenter, TopRight, MiddleLeft, DeadCenter, MiddleRight, BottomLeft, BottomCenter, BottomRight</li></ul></li><li><strong>rotationAngle</strong>: the rotation angle of the watermark. The value must be between 0 and 360 (inclusive). The default value is 0.</li><li><strong>pageSpanPercentage</strong>: the percentage of the page that the watermark spans on. The value must be between 1 and 100 (inclusive). The default value is 50.</li></ul></li></ul></li></ol>",
                  "value": {
                    "auditReasonId": 0,
                    "auditReasonComment": "",
                    "part": "Image",
                    "imageOptions": {
                      "format": "MultiPageTIFF",
                      "jpegCompressionLevel": 70,
                      "includeAnnotations": true,
                      "convertPdfAnnotations": true,
                      "pagePrefix": ", Page ",
                      "includeRedactions": true,
                      "watermark": {
                        "text": "",
                        "position": "DeadCenter",
                        "rotationAngle": 0,
                        "pageSpanPercentage": 50
                      }
                    }
                  }
                },
                "2": {
                  "summary": "Export the text part of a Laserfiche Document",
                  "description": "The body of the export request includes:<br /><ol><li>The audit event information to associate with the export operation.</li><li><strong>part</strong>: the part of the document to export. Options include: <strong>Image, Text, Edoc</strong>.</li><li><strong>textOptions</strong>: The options applied when exporting as Text.<ul><li><strong>includeRedactions</strong>: indicates if redactions are included. The default value is true.</li><li><strong>redactionCharacter</strong>: the character that replaces the original character in a redacted text. The value must be a string of length 1 and must not be a whitespace character. The default value is \"X\".</li></ul></li></ol>",
                  "value": {
                    "auditReasonId": 0,
                    "auditReasonComment": "",
                    "part": "Text",
                    "textOptions": {
                      "includeRedactions": true,
                      "redactionCharacter": "X"
                    }
                  }
                },
                "3": {
                  "summary": "Export the edoc part of a Laserfiche Document",
                  "description": "The body of the export request includes:<br /><ol><li>The audit event information to associate with the export operation.</li><li><strong>part</strong>: the part of the document to export. Options include: <strong>Image, Text, Edoc</strong>.</li></ol>",
                  "value": {
                    "auditReasonId": 0,
                    "auditReasonComment": "",
                    "part": "Edoc"
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 4
        },
        "responses": {
          "202": {
            "description": "A long operation task id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartTaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested repository not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "Export operation failed due to an internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/CopyAsync": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Starts an asynchronous copy task to copy an entry into a folder.",
        "description": "- Copy a new child entry in the designated folder async, and potentially return a taskId.\n- Provide the parent folder ID, and copy an entry as a child of the designated folder.\n- The status of the operation can be checked via the Tasks route.\n- Token substitution in the name of the copied entry is not supported.\n- Required OAuth scope: repository.Write",
        "operationId": "StartCopyEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The folder ID that the entry will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartCopyEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Copy an entry",
                  "description": "We can copy an entry (marked by sourceId property) to a destination (marked in URL).",
                  "value": {
                    "sourceId": 123,
                    "name": "CopiedEntry",
                    "autoRename": false
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "202": {
            "description": "A long operation task id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartTaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested repository not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}": {
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Starts an asynchronous delete task to delete an entry.",
        "description": "- Begins a task to delete an entry, and returns a taskId.\n- Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately.\n- Optionally include an audit reason ID and comment in the JSON body. This route returns a taskId, and will run as an asynchronous operation. Check the progress via the Tasks route.\n- Required OAuth scope: repository.Write",
        "operationId": "StartDeleteEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The submitted audit reason.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartDeleteEntryRequest"
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "202": {
            "description": "A long operation task id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartTaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested repository not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns a single entry object.",
        "description": "- Returns a single entry object.\n- Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc.\n- If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.\n- Allowed OData query options: Select.\n- Required OAuth scope: repository.Read",
        "operationId": "GetEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "A single entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Entries"
        ],
        "summary": "Update an entry. (Move and/or Rename)",
        "description": "- Update an entry. (Move and/or Rename)\n- Move an entry to a new folder by setting the ParentId in the request body.\n- Rename an entry by setting the Name in the request body.\n- Required OAuth scope: repository.Write",
        "operationId": "UpdateEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request containing the folder ID that the entry will be moved to and the new name the entry will be renamed to.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Move an entry",
                  "description": "We can move an entry by specifying the parent folder id in the request body.",
                  "value": {
                    "parentId": 123
                  }
                },
                "2": {
                  "summary": "Rename an entry",
                  "description": "We can rename an entry by specifying the new name of the entry in the request body.",
                  "value": {
                    "name": "NewName",
                    "autoRename": false
                  }
                },
                "3": {
                  "summary": "Move and Rename an entry",
                  "description": "We can move and rename an entry by specifying the parent folder id and the new name of the entry in the request body.",
                  "value": {
                    "parentId": 123,
                    "name": "NewName",
                    "autoRename": false
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "The updated entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "409": {
            "description": "Entry name conflicts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Import": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Imports a file into a folder (max length: 100 MB).",
        "description": "- Import a new document in the specified folder, and optionally assigns metadata.\n- The import may fail if the file is greater than 100 MB or time out if it takes longer than 60 seconds. These values are subject to change at anytime. Use the long operation asynchronous import if you run into these restrictions.\n- Required OAuth scope: repository.Write",
        "operationId": "ImportEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The entry ID of the folder that the document will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "required": [
                  "file",
                  "request"
                ],
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary"
                  },
                  "request": {
                    "$ref": "#/components/schemas/ImportEntryRequest"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "The created entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "Document creation is completely failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Export": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Exports an entry.",
        "description": "- Export an entry.\n- The export may time out if it takes longer than 60 seconds. This value is subject to change at anytime. Use the long operation asynchronous export if you run into this restriction.\n- Required OAuth scope: repository.Read",
        "operationId": "ExportEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The ID of entry to export.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "pageRange",
            "in": "query",
            "description": "A comma-separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when exporting as Edoc.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Export the image part of a Laserfiche Document",
                  "description": "The body of the export request includes:<br /><ol><li>The audit event information to associate with the export operation.</li><li><strong>part</strong>: the part of the document to export. Options include: <strong>Image, Text, Edoc</strong>.</li><li><strong>imageOptions</strong>: The options applied when exporting as Image.<ul><li><strong>format:</strong> the image format to export as. Options include: <strong>MultiPageTIFF, SinglePageTIFF, PNG, PDF, JPEG</strong>. The default value is MultiPageTIFF. MultiPageTIFF format is a single multi-page TIFF file. SinglePageTIFF format is multiple single-page TIFF files (in a single zip file).</li><li><strong>jpegCompressionLevel:</strong> the quality level for JPEG compression when exporting images. The value must be between 0 and 100 (inclusive). The default value is 70.</li><li><strong>includeAnnotations:</strong> indicates if the annotations need to be included. The default value is true.</li><li><strong>convertPdfAnnotations</strong>: indicates if the annotations on the image need to be converted to PDF annotations when exporting to PDF format. The default value is true. This option is only applicable when exporting to PDF format and includeAnnotations is true.</li><li><strong>pagePrefix</strong>: the page prefix of the individual files, when exporting to multi-file format (e.g.zip). The value must have a length of atmost 10 characters and only valid characters that can be included in file names are allowed. The default value is \", Page \".</li><li><strong>includeRedactions</strong>: indicates if redactions are included. The default value is true.</li><li><strong>watermark</strong>: the watermark element added to the image. This includes the following properties: <ul><li><strong>text</strong>: the text of the watermark. The value must be a string with a length of atmost 100 characters and must not be all whitespace characters. Using emojis in the text is not supported.</li><li><strong>position</strong>: the position of the watermark. The default value is DeadCenter. Assuming that the page is divided into a 3x3 grid, then position can be specified using the following values: <ul><li>TopLeft, TopCenter, TopRight, MiddleLeft, DeadCenter, MiddleRight, BottomLeft, BottomCenter, BottomRight</li></ul></li><li><strong>rotationAngle</strong>: the rotation angle of the watermark. The value must be between 0 and 360 (inclusive). The default value is 0.</li><li><strong>pageSpanPercentage</strong>: the percentage of the page that the watermark spans on. The value must be between 1 and 100 (inclusive). The default value is 50.</li></ul></li></ul></li></ol>",
                  "value": {
                    "auditReasonId": 0,
                    "auditReasonComment": "",
                    "part": "Image",
                    "imageOptions": {
                      "format": "MultiPageTIFF",
                      "jpegCompressionLevel": 70,
                      "includeAnnotations": true,
                      "convertPdfAnnotations": true,
                      "pagePrefix": ", Page ",
                      "includeRedactions": true,
                      "watermark": {
                        "text": "",
                        "position": "DeadCenter",
                        "rotationAngle": 0,
                        "pageSpanPercentage": 50
                      }
                    }
                  }
                },
                "2": {
                  "summary": "Export the text part of a Laserfiche Document",
                  "description": "The body of the export request includes:<br /><ol><li>The audit event information to associate with the export operation.</li><li><strong>part</strong>: the part of the document to export. Options include: <strong>Image, Text, Edoc</strong>.</li><li><strong>textOptions</strong>: The options applied when exporting as Text.<ul><li><strong>includeRedactions</strong>: indicates if redactions are included. The default value is true.</li><li><strong>redactionCharacter</strong>: the character that replaces the original character in a redacted text. The value must be a string of length 1 and must not be a whitespace character. The default value is \"X\".</li></ul></li></ol>",
                  "value": {
                    "auditReasonId": 0,
                    "auditReasonComment": "",
                    "part": "Text",
                    "textOptions": {
                      "includeRedactions": true,
                      "redactionCharacter": "X"
                    }
                  }
                },
                "3": {
                  "summary": "Export the edoc part of a Laserfiche Document",
                  "description": "The body of the export request includes:<br /><ol><li>The audit event information to associate with the export operation.</li><li><strong>part</strong>: the part of the document to export. Options include: <strong>Image, Text, Edoc</strong>.</li></ol>",
                  "value": {
                    "auditReasonId": 0,
                    "auditReasonComment": "",
                    "part": "Edoc"
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 4
        },
        "responses": {
          "200": {
            "description": "A link to download the exported entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportEntryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "Export operation failed due to an internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/ByPath": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns a single entry object using the entry path.",
        "description": "- Returns a single entry object using the entry path.\n- Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.\n- Required OAuth scope: repository.Read",
        "operationId": "GetEntryByPath",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "fullPath",
            "in": "query",
            "required": true,
            "description": "The requested entry path.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "fallbackToClosestAncestor",
            "in": "query",
            "description": "An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "The found entry or ancestor entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetEntryByPathResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested entry path not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Children": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the children entries of a folder.",
        "description": "- Returns the children entries of a folder in the repository.\n- Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository.\n- Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route.\n- Optional query parameters: groupByEntryType (bool). This query parameter decides if results are returned in groups based on their entry type. \n- Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.\n- Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: \"PropertyName direction,PropertyName2 direction\". Sort order can be either value \"asc\" or \"desc\".\n- Required OAuth scope: repository.Read",
        "operationId": "ListEntries",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The folder ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "groupByEntryType",
            "in": "query",
            "description": "Indicates if the result should be grouped by entry type or not. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 3
          },
          {
            "name": "fields",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "Optional array of field names. Field values corresponding to the given field names will be returned for each entry.",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 4
          },
          {
            "name": "formatFieldValues",
            "in": "query",
            "description": "Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 5
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 8
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 10
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 11
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 12
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 13
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of children entries of a folder.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Creates a new child entry in a folder.",
        "description": "- Create a new child entry in the designated folder.\n- Provide the parent folder ID, and based on the request body, create a folder/shortcut as a child entry of the designated folder.\n- Required OAuth scope: repository.Write",
        "operationId": "CreateEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The folder ID that the entry will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Create a folder",
                  "description": "We can create a new folder with the given name.",
                  "value": {
                    "entryType": "Folder",
                    "name": "NewFolder",
                    "autoRename": false
                  }
                },
                "2": {
                  "summary": "Create a shortcut",
                  "description": "We can create a new shortcut with the given name to the entry with the targetId.",
                  "value": {
                    "entryType": "Shortcut",
                    "name": "NewShortcut",
                    "autoRename": false,
                    "targetId": 123
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "201": {
            "description": "The created entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "409": {
            "description": "Entry name conflicts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Fields": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the fields assigned to an entry.",
        "description": "- Returns the fields assigned to an entry.\n- Provide an entry ID, and get a paged listing of all fields assigned to that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListFields",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "formatFieldValues",
            "in": "query",
            "description": "An optional query parameter used to indicate if the field values should be formatted. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 4
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 8
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 10
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 11
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of fields assigned to the entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FieldCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Updates the field values assigned to an entry.",
        "description": "- Update the field values assigned to an entry.\n- Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.\n- This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.\n- Required OAuth scope: repository.Write",
        "operationId": "SetFields",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The entry ID of the entry that will have its fields updated.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetFieldsRequest"
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "A collection of fields assigned to the entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FieldCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Tags": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the tags assigned to an entry.",
        "description": "- Returns the tags assigned to an entry.\n- Provide an entry ID, and get a paged listing of tags assigned to that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListTags",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of tags assigned to the entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Assigns tags to an entry.",
        "description": "- Assign tags to an entry.\n- Provide an entry ID and a list of tags to assign to that entry.\n- This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.\n- Required OAuth scope: repository.Write",
        "operationId": "SetTags",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The tags to add.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetTagsRequest"
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "A collection of tags assigned to the entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Links": {
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Assigns links to an entry.",
        "description": "- Assign links to an entry.\n- Provide an entry ID and a list of links to assign to that entry.\n- This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.\n- Required OAuth scope: repository.Write",
        "operationId": "SetLinks",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The request repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetLinksRequest"
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "A collection of links assigned to the entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LinkCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the links assigned to an entry.",
        "description": "- Returns the links assigned to an entry.\n- Provide an entry ID, and get a paged listing of links assigned to that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListLinks",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of links assigned to the entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LinkCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Copy": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Copies a new child entry in a folder.",
        "description": "- Copy a new child entry in the designated folder.\n- Provide the parent folder ID, and based on the request body, copy a child entry of the designated folder.\n- Required OAuth scope: repository.Write",
        "operationId": "CopyEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The folder ID that the entry will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CopyEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Copy an entry",
                  "description": "We can copy an entry (marked by sourceId property) to a destination (marked in URL).",
                  "value": {
                    "sourceId": 123,
                    "name": "CopiedEntry",
                    "autoRename": false
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "201": {
            "description": "The copied entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry ID not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "409": {
            "description": "Entry name conflicts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Document/Edoc": {
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Deletes the edoc associated with an entry.",
        "description": "- Delete the edoc associated with the provided entry ID.\n- Required OAuth scope: repository.Write ",
        "operationId": "DeleteElectronicDocument",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested document ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "The updated entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Document/Pages": {
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Deletes the pages associated with an entry.",
        "description": "- Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted.\n- Optional parameter: pageRange (default empty). The value should be a comma-separated string which contains non-overlapping single values, or page ranges. Ex: \"1,2,3\", \"1-3,5\", \"2-7,10-12.\"\n- Required OAuth scope: repository.Write",
        "operationId": "DeletePages",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested document ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "pageRange",
            "in": "query",
            "description": "The pages to be deleted.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "The updated entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Fields/GetDynamicFieldLogicValue": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the dynamic field logic values assigned to an entry.",
        "description": "- Returns dynamic field logic values with the current values of the fields in the template.\n- Provide an entry ID and field values in the JSON body to get dynamic field logic values.\n- Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.\n- Required OAuth scope: repository.Read",
        "operationId": "ListDynamicFieldValues",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request body.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDynamicFieldValuesRequest"
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "A collection of dynamic field values.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Entries/{entryId}/Template": {
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Removes the currently assigned template from an entry.",
        "description": "- Remove the currently assigned template from the specified entry.\n- Provide an entry ID to clear template value on.\n- If the entry does not have a template assigned, no change will be made.\n- Required OAuth scope: repository.Write",
        "operationId": "RemoveTemplate",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The ID of the entry that will have its template removed.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "The updated entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Assigns a template to an entry.",
        "description": "- Assign a template to an entry.\n- Provide an entry ID, template name, and a list of template fields to assign to that entry.\n- Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.\n- Required OAuth scope: repository.Write",
        "operationId": "SetTemplate",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The ID of entry that will have its template updated.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The template and template fields that will be assigned to the entry.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetTemplateRequest"
              },
              "examples": {
                "1": {
                  "summary": "Assign a template for an entry and not assign any field values for it",
                  "description": "We can set the template to an entry using the above request with fields having empty/default values.",
                  "value": {
                    "templateName": "sample template 1"
                  }
                },
                "2": {
                  "summary": "Assign a template with field values for an entry",
                  "description": "If the template contains fields Today and Address, we can set the template to an entry using the above request with specified fields values.",
                  "value": {
                    "templateName": "sample template 2",
                    "fields": [
                      {
                        "name": "Today",
                        "values": [
                          "2020-02-18T00:00:00"
                        ]
                      },
                      {
                        "name": "Address",
                        "values": [
                          "3545 Long Beach Blvd. Long Beach CA, 90807 U.S.A.",
                          "306, 1 Valleybrook Drive North York, Toronto, Ontario M3B2S7 CANADA",
                          "2307, Westlands Centre 20 Westlands Road Quarry Bay, Hong Kong"
                        ]
                      }
                    ]
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "The updated entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories": {
      "get": {
        "tags": [
          "Repositories"
        ],
        "summary": "Returns the list of repositories accessible to the user.",
        "description": "- Returns the repository resource list that current user has access to.\n- Required OAuth scope: repository.Read",
        "operationId": "ListRepositories",
        "responses": {
          "200": {
            "description": "A collection of respositories.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RepositoryCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Searches/SearchAsync": {
      "post": {
        "tags": [
          "Searches"
        ],
        "summary": "Starts an asynchronous search task.",
        "description": "- Runs a search operation on the repository.\n- The status for search operations must be checked via the Tasks route.\n- Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage).\n- Required OAuth scope: repository.Read",
        "operationId": "StartSearchEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The Laserfiche search command to run, optionally include fuzzy search settings.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartSearchEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Run an advanced search with fuzzy type",
                  "description": "Run an advanced search with fuzzy type based on number of letters",
                  "value": {
                    "searchCommand": "({LF:Basic ~= \"search text\", option=\"DFANLT\"})",
                    "fuzzyType": "NumberOfLetters",
                    "fuzzyFactor": 2
                  }
                },
                "2": {
                  "summary": "Run an advanced search with percentage fuzzy type",
                  "description": "Run an advanced search with fuzzy type based on percentage",
                  "value": {
                    "searchCommand": "({LF:Basic ~= \"search text\", option=\"DFANLT\"})",
                    "fuzzyType": "Percentage",
                    "fuzzyFactor": 80
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 2
        },
        "responses": {
          "202": {
            "description": "A long operation task id.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartTaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested repository not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Searches/{taskId}/Results": {
      "get": {
        "tags": [
          "Searches"
        ],
        "summary": "Returns the results listing associated with a search task.",
        "description": "- Returns a search result listing if the search is completed.\n- Search results expire after 5 minutes, but can be refreshed by retrieving the results again.\n- Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type.\n- Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values.\n- Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.\n- Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: \"PropertyName direction,PropertyName2 direction\". sort order can be either \"asc\" or \"desc\".\n- Required OAuth scope: repository.Read",
        "operationId": "ListSearchResults",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "taskId",
            "in": "path",
            "required": true,
            "description": "The requested task ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "groupByEntryType",
            "in": "query",
            "description": "Indicates if the result should be grouped by entry type or not. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 3
          },
          {
            "name": "refresh",
            "in": "query",
            "description": "Indicates if the search listing should be refreshed to show updated values. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 4
          },
          {
            "name": "fields",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "Optional array of field names. Field values corresponding to the given field names will be returned for each search result. ",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 5
          },
          {
            "name": "formatFieldValues",
            "in": "query",
            "description": "Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 6
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 8
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 9
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 11
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 12
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 13
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 14
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of entry search results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request taskId not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Searches/{taskId}/Results/{rowNumber}/ContextHits": {
      "get": {
        "tags": [
          "Searches"
        ],
        "summary": "Returns the context hits associated with a search result entry.",
        "description": "- Returns the context hits associated with a search result entry.\n- Given a taskId, and rowNumber associated with a search entry in the listing, return the context hits for that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListSearchContextHits",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "taskId",
            "in": "path",
            "required": true,
            "description": "The requested task ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "rowNumber",
            "in": "path",
            "required": true,
            "description": "The search result listing row number to get context hits for.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 3
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of context hits for a search result.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchContextHitCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request taskId not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/SimpleSearches": {
      "post": {
        "tags": [
          "SimpleSearches"
        ],
        "summary": "Runs a \"simple\" search operation.",
        "description": "- Runs a \"simple\" search operation on the repository.\n- Returns a truncated search result listing.\n- Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches.\n- Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.\n- Required OAuth scope: repository.Read",
        "operationId": "SearchEntry",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "fields",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "Optional array of field names. Field values corresponding to the given field names will be returned for each search result. ",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 2
          },
          {
            "name": "formatFieldValues",
            "in": "query",
            "description": "Indicates if field values should be formatted. Only applicable if Fields are specified. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The Laserfiche search command to run.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Run a search",
                  "description": "Run a simple search with LF search command. The \" in search command needs to be escaped.",
                  "value": {
                    "searchCommand": "({LF:Basic ~= \"search text\", option=\"DFANLT\"})"
                  }
                }
              }
            }
          },
          "required": true,
          "x-position": 4
        },
        "responses": {
          "200": {
            "description": "A collection of entry search results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryCollectionResponse"
                }
              }
            }
          },
          "206": {
            "description": "A truncated collection of entry search results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "413": {
            "description": "Request is too large.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/TagDefinitions": {
      "get": {
        "tags": [
          "TagDefinitions"
        ],
        "summary": "Returns the tag definitions associated with a repository.",
        "description": "- Returns all tag definitions in the repository.\n- Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListTagDefinitions",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of tag definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagDefinitionCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/TagDefinitions/{tagId}": {
      "get": {
        "tags": [
          "TagDefinitions"
        ],
        "summary": "Returns a single tag definition object.",
        "description": "- Returns a single tag definition.\n- Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed.\n- Allowed OData query options: Select\n- Required OAuth scope: repository.Read",
        "operationId": "GetTagDefinition",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "tagId",
            "in": "path",
            "required": true,
            "description": "The requested tag definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "responses": {
          "200": {
            "description": "A single tag definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagDefinition"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request tag definition id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/Tasks": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Returns the status of a set of one or more tasks.",
        "description": "- Returns the status of a set of one or more tasks.\n- Provide a comma-separated list of task IDs to get the task status, progress, and any errors that may have occurred.\n- Leave the taskIds query parameter empty, to get the list of all the task IDs associated with the current access token.\n- TaskStatus can be one of the following values: NotStarted, InProgress, Completed, Cancelled, or Failed.\n- This API employs long polling technique and could return the result immediately (e.g. if the export operation is failed or completed successfully) or after atmost 60 seconds.\n- Required OAuth scope: None",
        "operationId": "ListTasks",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "taskIds",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "An array of task IDs. Leave this parameter empty to get the list of all the tasks associated with the current access token.",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of task progresses.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Repository is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Tasks"
        ],
        "summary": "Starts the cancellation for a set of one or more tasks.",
        "description": "- Starts the cancellation for a set of one or more tasks.\n- Provide comma-separated list of task IDs to cancel. Should be used if an operation was created in error, or is no longer necessary.\n- Check the status of the task to determine if the task has been cancelled successfully.\n- Leave the taskIds query parameter empty, to cancel the list of all the task IDs associated with the current access token.\n- Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.\n- Required OAuth scope: None",
        "operationId": "CancelTasks",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "taskIds",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "An array of task IDs. Leave this parameter empty to cancel the list of all the tasks associated with the current access token.",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of task cancellation results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelTasksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Repository is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/TemplateDefinitions": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns the template definitions associated with a repository.",
        "description": "- Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned.\n- Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListTemplateDefinitions",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateName",
            "in": "query",
            "description": "An optional query parameter. Can be used to get a single template definition using the template name.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of template definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TemplateDefinitionCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template name not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/TemplateDefinitions/{templateId}": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns a single template definition object.",
        "description": "- Returns a single template definition (including field definitions, if relevant).\n- Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed.\n- Allowed OData query options: Select\n- Required OAuth scope: repository.Read",
        "operationId": "GetTemplateDefinition",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateId",
            "in": "path",
            "required": true,
            "description": "The requested template definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "responses": {
          "200": {
            "description": "A single template definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TemplateDefinition"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/TemplateDefinitions/{templateId}/FieldDefinitions": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns the field definitions assigned to a template definition (by template definition ID).",
        "description": "- Returns the field definitions assigned to a template definition.\n- Provide a template definition ID, and get a paged listing of the field definitions assigned to that template. \n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListTemplateFieldDefinitionsByTemplateId",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateId",
            "in": "path",
            "required": true,
            "description": "The requested template definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of template field definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TemplateFieldDefinitionCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v2/Repositories/{repositoryId}/TemplateDefinitions/FieldDefinitions": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns the field definitions assigned to a template definition (by template definition name).",
        "description": "- Returns the field definitions assigned to a template definition.\n- Provide a template definition name, and get a paged listing of the field definitions assigned to that template. \n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.\n- Required OAuth scope: repository.Read",
        "operationId": "ListTemplateFieldDefinitionsByTemplateName",
        "parameters": [
          {
            "name": "repositoryId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateName",
            "in": "query",
            "required": true,
            "description": "A required query parameter for the requested template name.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "A collection of template field definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TemplateFieldDefinitionCollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template name not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AttributeCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of Attribute.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Attribute"
            }
          }
        }
      },
      "Attribute": {
        "type": "object",
        "description": "Represents a trustee attribute.",
        "additionalProperties": false,
        "properties": {
          "key": {
            "type": "string",
            "description": "The attribute key.",
            "nullable": true
          },
          "value": {
            "type": "string",
            "description": "The attribute value.",
            "nullable": true
          }
        }
      },
      "ProblemDetails": {
        "type": "object",
        "description": "A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807.",
        "additionalProperties": {
          "nullable": true
        },
        "required": [
          "status"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "The problem type.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "A short, human-readable summary of the problem type.",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "description": "The HTTP status code.",
            "format": "int32"
          },
          "detail": {
            "type": "string",
            "description": "A human-readable explanation specific to this occurrence of the problem.",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "description": "A URI reference that identifies the specific occurrence of the problem.",
            "nullable": true
          },
          "operationId": {
            "type": "string",
            "description": "The operation id.",
            "nullable": true
          },
          "errorSource": {
            "type": "string",
            "description": "The error source.",
            "nullable": true
          },
          "errorCode": {
            "type": "integer",
            "description": "The error code.",
            "format": "int32",
            "nullable": true
          },
          "traceId": {
            "type": "string",
            "description": "The trace id.",
            "nullable": true
          },
          "instanceDetail": {
            "type": "string",
            "description": "The instance detail.",
            "nullable": true
          }
        }
      },
      "AuditReasonCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of AuditReason.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuditReason"
            }
          }
        }
      },
      "AuditReason": {
        "type": "object",
        "description": "Represents a user-defined audit reason for an audit event.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The audit reason id.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The audit reason text.",
            "nullable": true
          },
          "auditEventType": {
            "description": "The audit event type for this audit reason.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AuditEventType"
              }
            ]
          }
        }
      },
      "AuditEventType": {
        "type": "string",
        "description": "Enumeration of Laserfiche audit event types.",
        "x-enumNames": [
          "DeleteEntry",
          "ExportDocument"
        ],
        "enum": [
          "DeleteEntry",
          "ExportDocument"
        ]
      },
      "FieldDefinition": {
        "type": "object",
        "description": "Represents a field definition.",
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the field.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "The localized name of the field.",
            "nullable": true
          },
          "id": {
            "type": "integer",
            "description": "The ID of the field.",
            "format": "int32"
          },
          "description": {
            "type": "string",
            "description": "The description of the field.",
            "nullable": true
          },
          "fieldType": {
            "description": "The type of the field.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/FieldType"
              }
            ]
          },
          "length": {
            "type": "integer",
            "description": "The length of the field for variable length data types.",
            "format": "int32"
          },
          "defaultValue": {
            "type": "string",
            "description": "The default value of the field for new entries that are assigned to a template the represented field is a member of.",
            "nullable": true
          },
          "isMultiValue": {
            "type": "boolean",
            "description": "A boolean indicating if the represented template field supports multiple values."
          },
          "isRequired": {
            "type": "boolean",
            "description": "A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of."
          },
          "constraint": {
            "type": "string",
            "description": "The constraint for values stored in the represented field.",
            "nullable": true
          },
          "constraintError": {
            "type": "string",
            "description": "The error string that will be returned when the field constraint is violated when setting a value for this field.",
            "nullable": true
          },
          "listValues": {
            "type": "array",
            "description": "The list of items assigned to the represented field.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          },
          "format": {
            "description": "The display format of the represented field.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/FieldFormat"
              }
            ]
          },
          "currency": {
            "type": "string",
            "description": "The name of the currency that will be using when formatting the represented field when the Format property is set to the Currency member of the WFieldFormat enumeration.",
            "nullable": true
          },
          "formatPattern": {
            "type": "string",
            "description": "The custom format pattern for fields that are configured to use a custom format.",
            "nullable": true
          }
        }
      },
      "FieldType": {
        "type": "string",
        "description": "Enumeration of Laserfiche template field types.",
        "x-enumNames": [
          "DateTime",
          "Blob",
          "Date",
          "ShortInteger",
          "LongInteger",
          "List",
          "Number",
          "String",
          "Time"
        ],
        "enum": [
          "DateTime",
          "Blob",
          "Date",
          "ShortInteger",
          "LongInteger",
          "List",
          "Number",
          "String",
          "Time"
        ]
      },
      "FieldFormat": {
        "type": "string",
        "description": "Enumeration of Laserfiche template field formats.",
        "x-enumNames": [
          "None",
          "ShortDate",
          "LongDate",
          "ShortDateTime",
          "LongDateTime",
          "ShortTime",
          "LongTime",
          "GeneralNumber",
          "Currency",
          "Percent",
          "Scientific",
          "Custom"
        ],
        "enum": [
          "None",
          "ShortDate",
          "LongDate",
          "ShortDateTime",
          "LongDateTime",
          "ShortTime",
          "LongTime",
          "GeneralNumber",
          "Currency",
          "Percent",
          "Scientific",
          "Custom"
        ]
      },
      "FieldDefinitionCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of FieldDefinition.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FieldDefinition"
            }
          }
        }
      },
      "LinkDefinitionCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of LinkDefinition.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LinkDefinition"
            }
          }
        }
      },
      "LinkDefinition": {
        "type": "object",
        "description": "Represents an entry link definition.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the link definition.",
            "format": "int32"
          },
          "sourceLabel": {
            "type": "string",
            "description": "The label for the source entry in the link definition.",
            "nullable": true
          },
          "targetLabel": {
            "type": "string",
            "description": "The label for the target entry in the link definition.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The description of the link definition.",
            "nullable": true
          }
        }
      },
      "CreateMultipartUploadUrlsResponse": {
        "type": "object",
        "description": "Response for CreateMultipartUploadUrls.",
        "additionalProperties": false,
        "properties": {
          "uploadId": {
            "type": "string",
            "description": "A unique identifier for the whole upload process.",
            "nullable": true
          },
          "urls": {
            "type": "array",
            "description": "A list of URLs to which the file chunk should be written.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "CreateMultipartUploadUrlsRequest": {
        "type": "object",
        "description": "Request body for creating multipart upload urls.",
        "additionalProperties": false,
        "required": [
          "numberOfParts"
        ],
        "properties": {
          "uploadId": {
            "type": "string",
            "description": "A unique identifier for the whole upload process.",
            "default": "",
            "nullable": true
          },
          "startingPartNumber": {
            "type": "integer",
            "description": "Determines the starting position of the requested parts among all the parts associated with this upload. The default value is 1.",
            "format": "int32",
            "default": 1
          },
          "numberOfParts": {
            "type": "integer",
            "description": "The value must be in the range [1, 100], meaning that in each call to the CreateMultipartUploadUrls api, a maximum of 100 Upload URLs can be requested. Further, each file chunk written to an Upload URL should be at least 5 MB. There is no minimum size limit for the last chunk.",
            "format": "int32"
          },
          "fileName": {
            "type": "string",
            "description": "The name of the file to be uploaded. The file extension in the name will be used as the extension of the imported entry.",
            "nullable": true
          },
          "mimeType": {
            "type": "string",
            "description": "The mime-type of the file to be uploaded.",
            "nullable": true
          }
        }
      },
      "StartTaskResponse": {
        "type": "object",
        "description": "Response containing a long operation task id.",
        "additionalProperties": false,
        "properties": {
          "taskId": {
            "type": "string",
            "description": "A task ID that can be used to check on the status of the task.",
            "nullable": true
          }
        }
      },
      "StartImportUploadedPartsRequest": {
        "type": "object",
        "description": "Request body for starting an asynchronous import entry task.",
        "additionalProperties": false,
        "required": [
          "uploadId",
          "partETags",
          "name"
        ],
        "properties": {
          "uploadId": {
            "type": "string",
            "description": "The UploadId received when calling the CreateMultipartUploadUrls API to request upload URLs.",
            "minLength": 1
          },
          "partETags": {
            "type": "array",
            "description": "The array of the ETag values received when writing the file chunks into the upload URLs.",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "type": "string",
            "description": "The name for the imported entry.",
            "minLength": 1
          },
          "autoRename": {
            "type": "boolean",
            "description": "Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.",
            "default": false
          },
          "pdfOptions": {
            "description": "The options applied when importing a PDF.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ImportEntryRequestPdfOptions"
              }
            ]
          },
          "importAsElectronicDocument": {
            "type": "boolean",
            "description": "Indicates if the document should be imported as an electronic document (true) or as image pages (false). The default value is false. This option is only applicable when importing the following document types: txt, tif, tiff, bmp, pcx, jpg, jpeg, gif, png.",
            "default": false
          },
          "metadata": {
            "description": "The metadata that will be assigned to the entry.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ImportEntryRequestMetadata"
              }
            ]
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "ImportEntryRequestPdfOptions": {
        "type": "object",
        "description": "PDF-related options for importing an entry.",
        "additionalProperties": false,
        "properties": {
          "generateText": {
            "type": "boolean",
            "description": "Indicates if the import operation should generate text. The default value is false.",
            "default": false
          },
          "generatePages": {
            "type": "boolean",
            "description": "Indicates if the import operation should generate image pages. The default value is false.",
            "default": false
          },
          "generatePagesImageType": {
            "description": "The image type used when generating image pages. The default value is StandardColor. This option is only applicable when GeneratePages is true.",
            "default": "StandardColor",
            "oneOf": [
              {
                "$ref": "#/components/schemas/GeneratePagesImageType"
              }
            ]
          },
          "keepPdfAfterImport": {
            "type": "boolean",
            "description": "Indicates if the PDF file should be retained as an electronic document after generating image pages. The default value is true. This option is only applicable when GeneratePages is true.",
            "default": true
          }
        }
      },
      "GeneratePagesImageType": {
        "type": "string",
        "description": "Enumeration for the image types when generating pages.",
        "x-enumNames": [
          "BlackAndWhite",
          "StandardColor",
          "HighQualityColor"
        ],
        "enum": [
          "BlackAndWhite",
          "StandardColor",
          "HighQualityColor"
        ]
      },
      "ImportEntryRequestMetadata": {
        "type": "object",
        "description": "Represents the metadata that will be assigned to the imported entry.",
        "additionalProperties": false,
        "properties": {
          "templateName": {
            "type": "string",
            "description": "The name of the template assigned to the entry.",
            "nullable": true
          },
          "fields": {
            "type": "array",
            "description": "The fields that will be assigned to the entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/FieldToUpdate"
            }
          },
          "tags": {
            "type": "array",
            "description": "The tags that will be assigned to the entry.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          },
          "links": {
            "type": "array",
            "description": "The links that will be assigned to the entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/LinkToUpdate"
            }
          }
        }
      },
      "FieldToUpdate": {
        "type": "object",
        "description": "Represents a field that will be assigned to the entry.",
        "additionalProperties": false,
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the field that will be assigned to the entry.",
            "minLength": 1
          },
          "values": {
            "type": "array",
            "description": "The field values that will be assigned to the field.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "LinkToUpdate": {
        "type": "object",
        "description": "Represents a link that will be assigned to the entry.",
        "additionalProperties": false,
        "required": [
          "linkDefinitionId",
          "otherEntryId"
        ],
        "properties": {
          "linkDefinitionId": {
            "type": "integer",
            "description": "The id of the link definition to be assigned to the entry.",
            "format": "int32"
          },
          "otherEntryId": {
            "type": "integer",
            "description": "The id of the other entry to be linked to the entry.",
            "format": "int32"
          },
          "isSource": {
            "type": "boolean",
            "description": "Whether the entry is the source for the link. The default value is true.",
            "default": true
          },
          "customProperties": {
            "type": "object",
            "description": "Custom properties (key, value pairs) to be added to the link.",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "StartExportEntryRequest": {
        "type": "object",
        "description": "Request body for starting an asynchronous export entry task.",
        "additionalProperties": false,
        "required": [
          "part"
        ],
        "properties": {
          "auditReasonId": {
            "type": "integer",
            "description": "The reason id for this audit event.",
            "format": "int32"
          },
          "auditReasonComment": {
            "type": "string",
            "description": "The comment for this audit event.",
            "default": "",
            "nullable": true
          },
          "part": {
            "description": "Specifies the part of the document to export.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestPart"
              }
            ]
          },
          "imageOptions": {
            "description": "The options applied when exporting as Image.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestImageOptions"
              }
            ]
          },
          "textOptions": {
            "description": "The options applied when exporting as Text.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestTextOptions"
              }
            ]
          }
        }
      },
      "ExportEntryRequestPart": {
        "type": "string",
        "description": "Enumeration of the entry parts to export.",
        "x-enumNames": [
          "Image",
          "Text",
          "Edoc"
        ],
        "enum": [
          "Image",
          "Text",
          "Edoc"
        ]
      },
      "ExportEntryRequestImageOptions": {
        "type": "object",
        "description": "Represents the options when exporting the image part of an entry.",
        "additionalProperties": false,
        "properties": {
          "format": {
            "description": "The image format to export as. Options include: MultiPageTIFF, SinglePageTIFF, PNG, PDF and JPEG. The default value is MultiPageTIFF. MultiPageTIFF format is a single multi-page TIFF file. SinglePageTIFF format is multiple single-page TIFF files (in a single zip file).",
            "default": "MultiPageTIFF",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestImageFormat"
              }
            ]
          },
          "jPEGCompressionLevel": {
            "type": "integer",
            "description": "The quality level for JPEG compression when exporting images. The value must be between 0 and 100 (inclusive). The default value is 70.",
            "format": "int32",
            "default": 70
          },
          "includeAnnotations": {
            "type": "boolean",
            "description": "Indicates if the annotations need to be included. The default value is true.",
            "default": true
          },
          "convertPdfAnnotations": {
            "type": "boolean",
            "description": "Indicates if the annotations on the image need to be converted to PDF annotations when exporting to PDF format. The default value is true. This option is only applicable when exporting to PDF format and IncludeAnnotations is true.",
            "default": true
          },
          "pagePrefix": {
            "type": "string",
            "description": "The page prefix of the individual files, when exporting to multi-file format (e.g.zip). The value must have a length of atmost 10 characters and only valid characters that can be included in file names are allowed. The default value is \", Page \".",
            "default": ", Page ",
            "nullable": true
          },
          "includeRedactions": {
            "type": "boolean",
            "description": "Indicates if redactions are included. The default value is true.",
            "default": true
          },
          "watermark": {
            "description": "The watermark element added to each image. No watermark will be added by default.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestWatermark"
              }
            ]
          }
        }
      },
      "ExportEntryRequestImageFormat": {
        "type": "string",
        "description": "Enumeration of formats when exporting the image part of an entry.",
        "x-enumNames": [
          "MultiPageTIFF",
          "SinglePageTIFF",
          "PNG",
          "PDF",
          "JPEG"
        ],
        "enum": [
          "MultiPageTIFF",
          "SinglePageTIFF",
          "PNG",
          "PDF",
          "JPEG"
        ]
      },
      "ExportEntryRequestWatermark": {
        "type": "object",
        "description": "Represents the watermark added to the images when exporting an entry.",
        "additionalProperties": false,
        "properties": {
          "text": {
            "type": "string",
            "description": "The text of the watermark. The value must be a string with a length of atmost 100 characters and must not be all whitespace characters.",
            "default": "",
            "nullable": true
          },
          "position": {
            "description": "The position of the watermark. The default value is DeadCenter.",
            "default": "DeadCenter",
            "oneOf": [
              {
                "$ref": "#/components/schemas/WatermarkPosition"
              }
            ]
          },
          "rotationAngle": {
            "type": "integer",
            "description": "The rotation angle of the watermark. The value must be between 0 and 360 (inclusive). The default value is 0.",
            "format": "int32",
            "default": 0
          },
          "pageSpanPercentage": {
            "type": "integer",
            "description": "The percentage of the page that the watermark spans on. The value must be between 1 and 100 (inclusive). The default value is 50.",
            "format": "int32",
            "default": 50
          }
        }
      },
      "WatermarkPosition": {
        "type": "string",
        "description": "An enumeration of possible positions on a page for watermarks.",
        "x-enumNames": [
          "TopLeft",
          "TopCenter",
          "TopRight",
          "MiddleLeft",
          "DeadCenter",
          "MiddleRight",
          "BottomLeft",
          "BottomCenter",
          "BottomRight"
        ],
        "enum": [
          "TopLeft",
          "TopCenter",
          "TopRight",
          "MiddleLeft",
          "DeadCenter",
          "MiddleRight",
          "BottomLeft",
          "BottomCenter",
          "BottomRight"
        ]
      },
      "ExportEntryRequestTextOptions": {
        "type": "object",
        "description": "Represents the options when exporting the text part of an entry.",
        "additionalProperties": false,
        "properties": {
          "includeRedactions": {
            "type": "boolean",
            "description": "Indicates if redactions are included. The default value is true.",
            "default": true
          },
          "redactionCharacter": {
            "type": "string",
            "description": "The character that replaces the original character in a redacted text. The value must be a string of length 1 and must not be a whitespace character. The default value is 'X'.",
            "default": "X",
            "nullable": true
          }
        }
      },
      "StartCopyEntryRequest": {
        "type": "object",
        "description": "Request body for starting an asynchronous copy entry task.",
        "additionalProperties": false,
        "required": [
          "name",
          "sourceId"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the entry.",
            "minLength": 1
          },
          "autoRename": {
            "type": "boolean",
            "description": "Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.",
            "default": false
          },
          "sourceId": {
            "type": "integer",
            "description": "The source entry Id to copy.",
            "format": "int32"
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "StartDeleteEntryRequest": {
        "type": "object",
        "description": "Request body for starting an asynchronous delete entry task.",
        "additionalProperties": false,
        "properties": {
          "auditReasonId": {
            "type": "integer",
            "description": "The reason id for this audit event.",
            "format": "int32",
            "nullable": true
          },
          "auditReasonComment": {
            "type": "string",
            "description": "The comment for this audit event.",
            "nullable": true
          }
        }
      },
      "Entry": {
        "type": "object",
        "description": "Base type for all types which represent entry objects in a Laserfiche repository.",
        "x-abstract": true,
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the entry.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The name of the entry.",
            "nullable": true
          },
          "parentId": {
            "type": "integer",
            "description": "The ID of the parent entry.",
            "format": "int32",
            "nullable": true
          },
          "fullPath": {
            "type": "string",
            "description": "The full path in the Laserfiche repository to the entry.",
            "nullable": true
          },
          "folderPath": {
            "type": "string",
            "description": "The path in the Laserfiche repository to the parent folder.",
            "nullable": true
          },
          "creator": {
            "type": "string",
            "description": "The name of the user that created this entry.",
            "nullable": true
          },
          "creationTime": {
            "type": "string",
            "description": "The creation time of the entry.",
            "format": "date-time"
          },
          "lastModifiedTime": {
            "type": "string",
            "description": "The last modification time of the entry.",
            "format": "date-time"
          },
          "entryType": {
            "description": "The type of the entry.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/EntryType"
              }
            ]
          },
          "isContainer": {
            "type": "boolean",
            "description": "A boolean indicating if this entry is a container object; it can have other entries as children."
          },
          "isLeaf": {
            "type": "boolean",
            "description": "A boolean indicating if this entry is a leaf object; it cannot have other entries as children."
          },
          "templateName": {
            "type": "string",
            "description": "The name of the template assigned to this entry.",
            "nullable": true
          },
          "templateId": {
            "type": "integer",
            "description": "The id of the template assigned to this entry.",
            "format": "int32"
          },
          "templateFieldNames": {
            "type": "array",
            "description": "The names of the fields assigned to the template assigned to this entry.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume that this entry is associated with.",
            "nullable": true
          },
          "rowNumber": {
            "type": "integer",
            "description": "Row number assigned to this entry in the listing.",
            "format": "int32",
            "nullable": true
          },
          "fields": {
            "type": "array",
            "description": "The fields assigned to this entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/Field"
            }
          }
        }
      },
      "EntryType": {
        "type": "string",
        "description": "Enumeration of entry types.",
        "x-enumNames": [
          "Folder",
          "RecordSeries",
          "Document",
          "Shortcut"
        ],
        "enum": [
          "Folder",
          "RecordSeries",
          "Document",
          "Shortcut"
        ]
      },
      "Field": {
        "type": "object",
        "description": "Represents a field set on an entry.",
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the field.",
            "nullable": true
          },
          "fieldType": {
            "description": "The type of the field. The possible field types are listed below.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/FieldType"
              }
            ]
          },
          "id": {
            "type": "integer",
            "description": "The ID of the field.",
            "format": "int32"
          },
          "isMultiValue": {
            "type": "boolean",
            "description": "A boolean indicating if the represented field supports multiple values."
          },
          "isRequired": {
            "type": "boolean",
            "description": "A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of."
          },
          "hasMoreValues": {
            "type": "boolean",
            "description": "A boolean indicating if there are more field values."
          },
          "groupId": {
            "type": "integer",
            "description": "The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id.",
            "format": "int32",
            "nullable": true
          },
          "values": {
            "type": "array",
            "description": "The values assigned to the field.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "RecordSeries": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "description": "Represents a Laserfiche record series.",
            "additionalProperties": false
          }
        ]
      },
      "Document": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "description": "Represents a document in a Laserfiche repository.",
            "additionalProperties": false,
            "properties": {
              "electronicDocumentSize": {
                "type": "integer",
                "description": "The size of the electronic document attached to the represented document, if there is one, in bytes.",
                "format": "int64"
              },
              "extension": {
                "type": "string",
                "description": "The extension for the document.",
                "nullable": true
              },
              "isElectronicDocument": {
                "type": "boolean",
                "description": "A boolean indicating if there is an electronic document attached to the represented document."
              },
              "isRecord": {
                "type": "boolean",
                "description": "A boolean indicating if the represented document is a record."
              },
              "mimeType": {
                "type": "string",
                "description": "The MIME type of the electronic document.",
                "nullable": true
              },
              "pageCount": {
                "type": "integer",
                "description": "The page count of the represented document.",
                "format": "int32"
              },
              "isCheckedOut": {
                "type": "boolean",
                "description": "A boolean indicating if the represented document is checked out."
              },
              "isUnderVersionControl": {
                "type": "boolean",
                "description": "A boolean indicating if the represented document is under version control."
              }
            }
          }
        ]
      },
      "Shortcut": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "description": "Represents an entry shortcut in a Laserfiche repository.",
            "additionalProperties": false,
            "properties": {
              "targetId": {
                "type": "integer",
                "description": "The entry ID of the shortcut target.",
                "format": "int32"
              },
              "extension": {
                "type": "string",
                "description": "The extension of the shortcut target.",
                "nullable": true
              },
              "targetType": {
                "description": "The entry type of the shortcut target.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/EntryType"
                  }
                ]
              }
            }
          }
        ]
      },
      "Folder": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "description": "Represents a folder (standard or record folder) in a Laserfiche repository.",
            "additionalProperties": false,
            "properties": {
              "isRecordFolder": {
                "type": "boolean",
                "description": "A boolean indicating if the folder that this instance represents is known to be a record folder."
              },
              "isUnderRecordSeries": {
                "type": "boolean",
                "description": "A boolean indicating if the folder that this instance represents is known to directly or indirectly under a record series in the repository."
              }
            }
          }
        ]
      },
      "IHeaderDictionary": {
        "type": "object",
        "x-abstract": true,
        "additionalProperties": false,
        "properties": {
          "Item": {
            "type": "array",
            "items": {}
          },
          "ContentLength": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "Accept": {
            "type": "array",
            "items": {}
          },
          "AcceptCharset": {
            "type": "array",
            "items": {}
          },
          "AcceptEncoding": {
            "type": "array",
            "items": {}
          },
          "AcceptLanguage": {
            "type": "array",
            "items": {}
          },
          "AcceptRanges": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowCredentials": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowHeaders": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowMethods": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowOrigin": {
            "type": "array",
            "items": {}
          },
          "AccessControlExposeHeaders": {
            "type": "array",
            "items": {}
          },
          "AccessControlMaxAge": {
            "type": "array",
            "items": {}
          },
          "AccessControlRequestHeaders": {
            "type": "array",
            "items": {}
          },
          "AccessControlRequestMethod": {
            "type": "array",
            "items": {}
          },
          "Age": {
            "type": "array",
            "items": {}
          },
          "Allow": {
            "type": "array",
            "items": {}
          },
          "AltSvc": {
            "type": "array",
            "items": {}
          },
          "Authorization": {
            "type": "array",
            "items": {}
          },
          "Baggage": {
            "type": "array",
            "items": {}
          },
          "CacheControl": {
            "type": "array",
            "items": {}
          },
          "Connection": {
            "type": "array",
            "items": {}
          },
          "ContentDisposition": {
            "type": "array",
            "items": {}
          },
          "ContentEncoding": {
            "type": "array",
            "items": {}
          },
          "ContentLanguage": {
            "type": "array",
            "items": {}
          },
          "ContentLocation": {
            "type": "array",
            "items": {}
          },
          "ContentMD5": {
            "type": "array",
            "items": {}
          },
          "ContentRange": {
            "type": "array",
            "items": {}
          },
          "ContentSecurityPolicy": {
            "type": "array",
            "items": {}
          },
          "ContentSecurityPolicyReportOnly": {
            "type": "array",
            "items": {}
          },
          "ContentType": {
            "type": "array",
            "items": {}
          },
          "CorrelationContext": {
            "type": "array",
            "items": {}
          },
          "Cookie": {
            "type": "array",
            "items": {}
          },
          "Date": {
            "type": "array",
            "items": {}
          },
          "ETag": {
            "type": "array",
            "items": {}
          },
          "Expires": {
            "type": "array",
            "items": {}
          },
          "Expect": {
            "type": "array",
            "items": {}
          },
          "From": {
            "type": "array",
            "items": {}
          },
          "GrpcAcceptEncoding": {
            "type": "array",
            "items": {}
          },
          "GrpcEncoding": {
            "type": "array",
            "items": {}
          },
          "GrpcMessage": {
            "type": "array",
            "items": {}
          },
          "GrpcStatus": {
            "type": "array",
            "items": {}
          },
          "GrpcTimeout": {
            "type": "array",
            "items": {}
          },
          "Host": {
            "type": "array",
            "items": {}
          },
          "KeepAlive": {
            "type": "array",
            "items": {}
          },
          "IfMatch": {
            "type": "array",
            "items": {}
          },
          "IfModifiedSince": {
            "type": "array",
            "items": {}
          },
          "IfNoneMatch": {
            "type": "array",
            "items": {}
          },
          "IfRange": {
            "type": "array",
            "items": {}
          },
          "IfUnmodifiedSince": {
            "type": "array",
            "items": {}
          },
          "LastModified": {
            "type": "array",
            "items": {}
          },
          "Link": {
            "type": "array",
            "items": {}
          },
          "Location": {
            "type": "array",
            "items": {}
          },
          "MaxForwards": {
            "type": "array",
            "items": {}
          },
          "Origin": {
            "type": "array",
            "items": {}
          },
          "Pragma": {
            "type": "array",
            "items": {}
          },
          "ProxyAuthenticate": {
            "type": "array",
            "items": {}
          },
          "ProxyAuthorization": {
            "type": "array",
            "items": {}
          },
          "ProxyConnection": {
            "type": "array",
            "items": {}
          },
          "Range": {
            "type": "array",
            "items": {}
          },
          "Referer": {
            "type": "array",
            "items": {}
          },
          "RetryAfter": {
            "type": "array",
            "items": {}
          },
          "RequestId": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketAccept": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketKey": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketProtocol": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketVersion": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketExtensions": {
            "type": "array",
            "items": {}
          },
          "Server": {
            "type": "array",
            "items": {}
          },
          "SetCookie": {
            "type": "array",
            "items": {}
          },
          "StrictTransportSecurity": {
            "type": "array",
            "items": {}
          },
          "TE": {
            "type": "array",
            "items": {}
          },
          "Trailer": {
            "type": "array",
            "items": {}
          },
          "TransferEncoding": {
            "type": "array",
            "items": {}
          },
          "Translate": {
            "type": "array",
            "items": {}
          },
          "TraceParent": {
            "type": "array",
            "items": {}
          },
          "TraceState": {
            "type": "array",
            "items": {}
          },
          "Upgrade": {
            "type": "array",
            "items": {}
          },
          "UpgradeInsecureRequests": {
            "type": "array",
            "items": {}
          },
          "UserAgent": {
            "type": "array",
            "items": {}
          },
          "Vary": {
            "type": "array",
            "items": {}
          },
          "Via": {
            "type": "array",
            "items": {}
          },
          "Warning": {
            "type": "array",
            "items": {}
          },
          "WebSocketSubProtocols": {
            "type": "array",
            "items": {}
          },
          "WWWAuthenticate": {
            "type": "array",
            "items": {}
          },
          "XContentTypeOptions": {
            "type": "array",
            "items": {}
          },
          "XFrameOptions": {
            "type": "array",
            "items": {}
          },
          "XPoweredBy": {
            "type": "array",
            "items": {}
          },
          "XRequestedWith": {
            "type": "array",
            "items": {}
          },
          "XUACompatible": {
            "type": "array",
            "items": {}
          },
          "XXSSProtection": {
            "type": "array",
            "items": {}
          }
        }
      },
      "ImportEntryRequest": {
        "type": "object",
        "description": "Request body for importing an entry.",
        "additionalProperties": false,
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name for the imported entry."
          },
          "autoRename": {
            "type": "boolean",
            "description": "Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.",
            "default": false
          },
          "pdfOptions": {
            "description": "The options applied when importing a PDF.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ImportEntryRequestPdfOptions"
              }
            ]
          },
          "importAsElectronicDocument": {
            "type": "boolean",
            "description": "Indicates if the document should be imported as an electronic document (true) or as image pages (false). The default value is false. This option is only applicable when importing the following document types: txt, tif, tiff, bmp, pcx, jpg, jpeg, gif, png.",
            "default": false
          },
          "metadata": {
            "description": "The metadata that will be assigned to the entry.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ImportEntryRequestMetadata"
              }
            ]
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "ExportEntryResponse": {
        "type": "object",
        "description": "Response containing a link to download the exported entry.",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "string"
          }
        }
      },
      "ExportEntryRequest": {
        "type": "object",
        "description": "Request body for exporting an entry.",
        "additionalProperties": false,
        "required": [
          "part"
        ],
        "properties": {
          "auditReasonId": {
            "type": "integer",
            "description": "The reason id for this audit event.",
            "format": "int32"
          },
          "auditReasonComment": {
            "type": "string",
            "description": "The comment for this audit event.",
            "default": "",
            "nullable": true
          },
          "part": {
            "description": "The part of the document to export. Options include: Image, Text, Edoc.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestPart"
              }
            ]
          },
          "imageOptions": {
            "description": "The options applied when exporting as Image.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestImageOptions"
              }
            ]
          },
          "textOptions": {
            "description": "The options applied when exporting as Text.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/ExportEntryRequestTextOptions"
              }
            ]
          }
        }
      },
      "GetEntryByPathResponse": {
        "type": "object",
        "description": "Response containing an entry or ancestor entry found by entry path.",
        "additionalProperties": false,
        "properties": {
          "entry": {
            "description": "The entry found by path. This property is set if entry is found.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/Entry"
              }
            ]
          },
          "ancestorEntry": {
            "description": "The closest entry ancestor. This property is set if entry is not found and fallbackToClosestAncestor is set to true.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/Entry"
              }
            ]
          }
        }
      },
      "UpdateEntryRequest": {
        "type": "object",
        "description": "Request body for updating an entry.",
        "additionalProperties": false,
        "properties": {
          "parentId": {
            "type": "integer",
            "description": "The ID of the parent entry that the entry will be moved to.",
            "format": "int32",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The name that will be assigned to the entry.",
            "nullable": true
          },
          "autoRename": {
            "type": "boolean",
            "description": "Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.",
            "default": false
          }
        }
      },
      "EntryCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of Entry.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Entry"
            }
          }
        }
      },
      "FieldCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of Field.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            }
          }
        }
      },
      "SetFieldsRequest": {
        "type": "object",
        "description": "Request body for assigning fields to an entry.",
        "additionalProperties": false,
        "properties": {
          "fields": {
            "type": "array",
            "description": "The fields that will be assigned to the entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/FieldToUpdate"
            }
          }
        }
      },
      "TagCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of Tag.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Tag"
            }
          }
        }
      },
      "Tag": {
        "type": "object",
        "description": "Represents a tag set on an entry.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the tag definition.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The name of the tag definition.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "The localized name of the tag definition.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The description of the tag definition.",
            "nullable": true
          },
          "isSecure": {
            "type": "boolean",
            "description": "A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false)."
          },
          "watermark": {
            "description": "The watermark properties associated with the tag definition.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/TagDefinitionWatermark"
              }
            ]
          }
        }
      },
      "TagDefinitionWatermark": {
        "type": "object",
        "description": "Represents a watermark associated with a tag defintion.",
        "additionalProperties": false,
        "properties": {
          "text": {
            "type": "string",
            "description": "The watermark text associated with the tag defintion.",
            "nullable": true
          },
          "pageSpanPercentage": {
            "type": "integer",
            "description": "The percentage of the page that the watermark associated with the tag definition spans on.",
            "format": "int32"
          },
          "position": {
            "description": "The position of the watermark on the page.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/WatermarkPosition"
              }
            ]
          },
          "rotationAngle": {
            "type": "integer",
            "description": "The rotation angle, in degrees, of the watermark associated with the tag definition.",
            "format": "int32"
          },
          "isMandatory": {
            "type": "boolean",
            "description": "A boolean indicating whether or not the watermark associated with the tag is mandatory."
          },
          "opacity": {
            "type": "integer",
            "description": "The opacity of the watermark associated with the tag definition. Valid value ranges from 0 to 100, with -1 as the default values.",
            "format": "int32"
          }
        }
      },
      "SetTagsRequest": {
        "type": "object",
        "description": "Request body for assigning tags to an entry.",
        "additionalProperties": false,
        "properties": {
          "tags": {
            "type": "array",
            "description": "The tag names to assign to the entry.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "LinkCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of Link.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            }
          }
        }
      },
      "Link": {
        "type": "object",
        "description": "Represents a link between a source entry and a target entry.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the represented link.",
            "format": "int32"
          },
          "description": {
            "type": "string",
            "description": "The description for the represented link.",
            "nullable": true
          },
          "sourceId": {
            "type": "integer",
            "description": "The ID of the source entry of the represented link.",
            "format": "int32"
          },
          "sourceFullPath": {
            "type": "string",
            "description": "The full path to the source entry of the represented link.",
            "nullable": true
          },
          "sourceLabel": {
            "type": "string",
            "description": "The label for the source entry in the link definition.",
            "nullable": true
          },
          "sourceLink": {
            "type": "string",
            "description": "The navigation link to the source entry.",
            "nullable": true
          },
          "targetId": {
            "type": "integer",
            "description": "The ID of the target entry of the represented link.",
            "format": "int32"
          },
          "targetFullPath": {
            "type": "string",
            "description": "The full path to the target entry of the represented link.",
            "nullable": true
          },
          "targetLabel": {
            "type": "string",
            "description": "The label for the target entry in the link definition.",
            "nullable": true
          },
          "targetLink": {
            "type": "string",
            "description": "The navigation link to the target entry.",
            "nullable": true
          },
          "linkDefinitionId": {
            "type": "integer",
            "description": "The ID of the link definition.",
            "format": "int32"
          },
          "linkDefinitionDescription": {
            "type": "string",
            "description": "The description of the link definition.",
            "nullable": true
          },
          "customProperties": {
            "type": "object",
            "description": "The custom properties for the represented link.",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "SetLinksRequest": {
        "type": "object",
        "description": "Request body for assigning links to an entry.",
        "additionalProperties": false,
        "properties": {
          "links": {
            "type": "array",
            "description": "The links that will be assigned to the entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/LinkToUpdate"
            }
          }
        }
      },
      "CopyEntryRequest": {
        "type": "object",
        "description": "Request body for copying an entry.",
        "additionalProperties": false,
        "required": [
          "name",
          "sourceId"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the entry.",
            "minLength": 1
          },
          "autoRename": {
            "type": "boolean",
            "description": "Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.",
            "default": false
          },
          "sourceId": {
            "type": "integer",
            "description": "The source entry Id to copy.",
            "format": "int32"
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "CreateEntryRequest": {
        "type": "object",
        "description": "Request body for creating an entry.",
        "additionalProperties": false,
        "required": [
          "name",
          "entryType"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the entry.",
            "minLength": 1
          },
          "autoRename": {
            "type": "boolean",
            "description": "Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false.",
            "default": false
          },
          "entryType": {
            "description": "The type of the entry.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateEntryRequestEntryType"
              }
            ]
          },
          "targetId": {
            "type": "integer",
            "description": "The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target.",
            "format": "int32"
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "CreateEntryRequestEntryType": {
        "type": "string",
        "description": "Enumeration of entry types for CreateEntry.",
        "x-enumNames": [
          "Folder",
          "Shortcut"
        ],
        "enum": [
          "Folder",
          "Shortcut"
        ]
      },
      "ListDynamicFieldValuesRequest": {
        "type": "object",
        "description": "Request body for listing dynamic field values for an entry.",
        "additionalProperties": false,
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "integer",
            "description": "The template id.",
            "format": "int32"
          },
          "fieldValues": {
            "type": "object",
            "description": "The dynamic fields.",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "SetTemplateRequest": {
        "type": "object",
        "description": "Request body for assigning a template and template fields to an entry.",
        "additionalProperties": false,
        "required": [
          "templateName"
        ],
        "properties": {
          "templateName": {
            "type": "string",
            "description": "The template that will be assigned to the entry.",
            "minLength": 1
          },
          "fields": {
            "type": "array",
            "description": "The template fields that will be assigned to the entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/FieldToUpdate"
            }
          }
        }
      },
      "RepositoryCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of Repository.",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Repository"
            }
          }
        }
      },
      "Repository": {
        "type": "object",
        "description": "Represents a Laserfiche repository.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "string",
            "description": "The repository id.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The repository name.",
            "nullable": true
          },
          "webClientUrl": {
            "type": "string",
            "description": "The corresponding repository Web Client url.",
            "nullable": true
          }
        }
      },
      "StartSearchEntryRequest": {
        "type": "object",
        "description": "Request body for starting an asynchronous search entry task.",
        "additionalProperties": false,
        "required": [
          "searchCommand"
        ],
        "properties": {
          "searchCommand": {
            "type": "string",
            "description": "The search command to run. The search command should follow the Laserfiche search syntax. https://doc.laserfiche.com/laserfiche.documentation/en-us/Default.htm#Search_Syntax.htm",
            "minLength": 1
          },
          "fuzzyType": {
            "description": "Fuzzy type (None, Percentage, or NumberOfLetters).",
            "oneOf": [
              {
                "$ref": "#/components/schemas/FuzzyType"
              }
            ]
          },
          "fuzzyFactor": {
            "type": "integer",
            "description": "Fuzzy factor (percentage as int or int value).",
            "format": "int32"
          }
        }
      },
      "FuzzyType": {
        "type": "string",
        "description": "",
        "x-enumNames": [
          "None",
          "Percentage",
          "NumberOfLetters"
        ],
        "enum": [
          "None",
          "Percentage",
          "NumberOfLetters"
        ]
      },
      "SearchContextHitCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of SearchContextHit.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchContextHit"
            }
          }
        }
      },
      "SearchContextHit": {
        "type": "object",
        "description": "Represents a context hit for a search result.",
        "additionalProperties": false,
        "properties": {
          "hitType": {
            "description": "The type of context hit this instance represents.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/HitType"
              }
            ]
          },
          "isAnnotationHit": {
            "type": "boolean",
            "description": "A boolean indicating if this context hit occurs on an annotation."
          },
          "annotationId": {
            "type": "integer",
            "description": "The ID of the annotation that the context hit is in.",
            "format": "int32"
          },
          "pageNumber": {
            "type": "integer",
            "description": "The page number in the document of the search hit's context.",
            "format": "int32"
          },
          "pageOffset": {
            "type": "integer",
            "description": "The offset from the beginning of the page of the starting character of the search hit's context line.",
            "format": "int32"
          },
          "context": {
            "type": "string",
            "description": "The line of context for the search hit.",
            "nullable": true
          },
          "highlight1Offset": {
            "type": "integer",
            "description": "The character offset from the beginning of the context line of the start of the first highlight.",
            "format": "int32"
          },
          "highlight1Length": {
            "type": "integer",
            "description": "The length of the first highlight in characters.",
            "format": "int32"
          },
          "highlight2Offset": {
            "type": "integer",
            "description": "The character offset from the beginning of the context line of the start of the second highlight.",
            "format": "int32"
          },
          "highlight2Length": {
            "type": "integer",
            "description": "The length of the second highlight in characters.",
            "format": "int32"
          },
          "hitWidth": {
            "type": "integer",
            "description": "The number of words in the context hit.",
            "format": "int32"
          },
          "edocHitCount": {
            "type": "integer",
            "description": "The number of hits in the electronic document.",
            "format": "int32"
          },
          "fieldHitCount": {
            "type": "integer",
            "description": "The number of hits in the template.",
            "format": "int32"
          },
          "fieldName": {
            "type": "string",
            "description": "The name of a template field containing the hit.",
            "nullable": true
          },
          "hitNumber": {
            "type": "integer",
            "description": "The hit number.",
            "format": "int32"
          }
        }
      },
      "HitType": {
        "type": "string",
        "description": "The type of context hit.",
        "x-enumNames": [
          "PageContent",
          "Note",
          "Callout",
          "TextBox",
          "Edoc",
          "Prop",
          "Name",
          "Extension",
          "VersionGroupNote",
          "VersionComment",
          "Field",
          "SignatureComment",
          "CertificateSubject",
          "TagComment",
          "AnnotationComment",
          "Attachment"
        ],
        "enum": [
          "PageContent",
          "Note",
          "Callout",
          "TextBox",
          "Edoc",
          "Prop",
          "Name",
          "Extension",
          "VersionGroupNote",
          "VersionComment",
          "Field",
          "SignatureComment",
          "CertificateSubject",
          "TagComment",
          "AnnotationComment",
          "Attachment"
        ]
      },
      "SearchEntryRequest": {
        "type": "object",
        "description": "Request body for searching entries.",
        "additionalProperties": false,
        "required": [
          "searchCommand"
        ],
        "properties": {
          "searchCommand": {
            "type": "string",
            "description": "The search command to run. The search command should follow the Laserfiche search syntax. https://doc.laserfiche.com/laserfiche.documentation/en-us/Default.htm#Search_Syntax.htm",
            "minLength": 1
          }
        }
      },
      "TagDefinitionCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of TagDefinition.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagDefinition"
            }
          }
        }
      },
      "TagDefinition": {
        "type": "object",
        "description": "Represents an entry tag definition.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the tag definition.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The name of the tag definition.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "The localized name of the tag definition.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The description of the tag definition.",
            "nullable": true
          },
          "isSecure": {
            "type": "boolean",
            "description": "A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false)."
          },
          "watermark": {
            "description": "The watermark properties associated with the tag definition.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/TagDefinitionWatermark"
              }
            ]
          }
        }
      },
      "TaskCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of TaskProgress.",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskProgress"
            }
          }
        }
      },
      "TaskProgress": {
        "type": "object",
        "description": "Represents the progress of a long operation task.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "string",
            "description": "The task ID of the task associated with this TaskProgress.",
            "nullable": true
          },
          "taskType": {
            "description": "The type of the task associated with this TaskProgress.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TaskType"
              }
            ]
          },
          "percentComplete": {
            "type": "integer",
            "description": "Determines what percentage of the execution of the associated task is completed.",
            "format": "int32"
          },
          "status": {
            "description": "The status of the task associated with this TaskProgress.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TaskStatus"
              }
            ]
          },
          "errors": {
            "type": "array",
            "description": "The list of errors occurred during the execution of the associated task.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ProblemDetails"
            }
          },
          "result": {
            "description": "The result of the execution of the associated task.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/TaskResult"
              }
            ]
          },
          "startTime": {
            "type": "string",
            "description": "The time representing when the associated task's execution started.",
            "format": "date-time"
          },
          "lastUpdateTime": {
            "type": "string",
            "description": "The time representing when the associated task's status last changed.",
            "format": "date-time"
          }
        }
      },
      "TaskType": {
        "type": "string",
        "description": "An enumeration of possible types for a long operation task.",
        "x-enumNames": [
          "CopyEntry",
          "DeleteEntry",
          "ExportEntry",
          "ImportUploadedParts",
          "SearchEntry"
        ],
        "enum": [
          "CopyEntry",
          "DeleteEntry",
          "ExportEntry",
          "ImportUploadedParts",
          "SearchEntry"
        ]
      },
      "TaskStatus": {
        "type": "string",
        "description": "An enumeration of possible statuses for a long operation task.",
        "x-enumNames": [
          "NotStarted",
          "InProgress",
          "Completed",
          "Failed",
          "Cancelled"
        ],
        "enum": [
          "NotStarted",
          "InProgress",
          "Completed",
          "Failed",
          "Cancelled"
        ]
      },
      "TaskResult": {
        "type": "object",
        "description": "Represents the result of a long operation task.",
        "additionalProperties": false,
        "properties": {
          "entryId": {
            "type": "integer",
            "description": "The ID of the entry which is affected (e.g. created or modified) by the execution of the associated task.",
            "format": "int32"
          },
          "uri": {
            "type": "string",
            "description": "The URI which can be used (via api call) to access the result(s) of the associated task.",
            "nullable": true
          }
        }
      },
      "CancelTasksResponse": {
        "type": "object",
        "description": "Response containing a collection of CancelTaskResult.",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CancelTaskResult"
            }
          }
        }
      },
      "CancelTaskResult": {
        "type": "object",
        "description": "Represents the result of cancelling a long operation task.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the task which has been subject to cancellation.",
            "nullable": true
          },
          "taskType": {
            "description": "The type of the task which has been subject to cancellation.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TaskType"
              }
            ]
          },
          "result": {
            "type": "boolean",
            "description": "Indicates if the request to cancel the task has been received."
          }
        }
      },
      "TemplateDefinitionCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of TemplateDefinition.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TemplateDefinition"
            }
          }
        }
      },
      "TemplateDefinition": {
        "type": "object",
        "description": "Represents a template definition.",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the template definition.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The name of the template definition.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "The localized name of the template definition.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The description of the template definition.",
            "nullable": true
          },
          "color": {
            "description": "The color assigned to the template definition.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/LFColor"
              }
            ]
          },
          "fieldCount": {
            "type": "integer",
            "description": "The number of field definitions assigned to the template definition.",
            "format": "int32"
          }
        }
      },
      "LFColor": {
        "type": "object",
        "description": "Represents an RGB color value with alpha channel.",
        "additionalProperties": false,
        "properties": {
          "a": {
            "type": "integer",
            "description": "The alpha channel component, from 0-255.",
            "format": "byte"
          },
          "r": {
            "type": "integer",
            "description": "The red channel component, from 0-255.",
            "format": "byte"
          },
          "g": {
            "type": "integer",
            "description": "The green channel component, from 0-255.",
            "format": "byte"
          },
          "b": {
            "type": "integer",
            "description": "The blue channel component from 0-255.",
            "format": "byte"
          }
        }
      },
      "TemplateFieldDefinitionCollectionResponse": {
        "type": "object",
        "description": "Response containing a collection of TemplateFieldDefinition.",
        "additionalProperties": false,
        "properties": {
          "@odata.nextLink": {
            "type": "string",
            "description": "A URL to retrieve the next page of the requested collection.",
            "nullable": true
          },
          "@odata.count": {
            "type": "integer",
            "description": "The total count of items within a collection.",
            "format": "int32",
            "nullable": true
          },
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TemplateFieldDefinition"
            }
          }
        }
      },
      "TemplateFieldDefinition": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FieldDefinition"
          },
          {
            "type": "object",
            "description": "Represents a template field definition.",
            "additionalProperties": false,
            "properties": {
              "rule": {
                "description": "A form logic rule associated with a Laserfiche template and field definition.",
                "nullable": true,
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/Rule"
                  }
                ]
              },
              "groupId": {
                "type": "integer",
                "description": "The group id of the field in the template.",
                "format": "int32"
              },
              "groupName": {
                "type": "string",
                "description": "The name of field group.",
                "nullable": true
              }
            }
          }
        ]
      },
      "Rule": {
        "type": "object",
        "description": "Represents a form logic rule associated with a Laserfiche template and field definition.",
        "additionalProperties": false,
        "properties": {
          "ancestors": {
            "type": "array",
            "description": "The IDs of the parent fields in the template according to the form logic rule.",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int32"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "Authorization": {
        "type": "http",
        "description": "Type your token into the textbox.",
        "scheme": "bearer"
      },
      "OAuth2 Authorization Code Flow": {
        "type": "oauth2",
        "description": "<p>Note: Please enter below the clientId/clientSecret of a registered web application, or the clientId of a SPA. For SPA, the clientSecret field must be left empty. The app, either a web application or SPA, must have the following uri defined as its redirect uri.</p><p>https://api.laserfiche.com/repository/swagger/oauth2-redirect.html</p><p>For more information, see <a href=\"https://developer.laserfiche.com/guides/guide_authenticating-to-the-swagger-playground.html\" target=\"_blank\">this page</a></p>",
        "flows": {
          "authorizationCode": {
            "authorizationUrl": "https://signin.a.clouddev.laserfiche.com/oauth/Authorize",
            "tokenUrl": "https://signin.a.clouddev.laserfiche.com/oauth/Token",
            "scopes": {
              "repository.Read": "Allows the app to read the content of Laserfiche repositories on behalf of the signed-in user.",
              "repository.Write": "Allows the app to modify the content of Laserfiche repositories on behalf of the signed-in user."
            }
          }
        }
      }
    }
  },
  "security": [
    {
      "Authorization": []
    },
    {
      "OAuth2 Authorization Code Flow": []
    }
  ]
}