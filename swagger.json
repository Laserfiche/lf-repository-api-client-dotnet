{
  "x-generator": "NSwag v13.14.8.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v13.0.0.0))",
  "openapi": "3.0.0",
  "info": {
    "title": "Laserfiche Repository API",
    "description": "Welcome to the Laserfiche API Swagger Playground. You can try out any of our API calls against your live Laserfiche Cloud account. Visit the developer center for more details: <a href=\"https://developer.laserfiche.com\">https://developer.laserfiche.com</a><p>Visit the changelog for the list of changes: <a href=\"/v1/changelog\">/v1/changelog</a></p><p><strong>Build# : </strong></p>",
    "version": "1"
  },
  "servers": [
    {
      "url": "https://api.laserfiche.com/repository"
    }
  ],
  "paths": {
    "/v1/Repositories/{repoId}/Entries/{parentEntryId}/{fileName}": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Creates a new document in the specified folder with file (no more than 100 MB). Optionally sets metadata and electronic document component. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed. With this route, partial success is possible. The response returns multiple operation (entryCreate operation, setEdoc operation, setLinks operation, etc..) objects, which contain information about any errors that may have occurred during the creation. As long as the entryCreate operation succeeds, the entry will be created, even if all other operations fail.",
        "description": "- Creates a new document in the specified folder with file (no more than 100 MB).\n- Optionally sets metadata and electronic document component.\n- Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed. With this route, partial success is possible. The response returns multiple operation (entryCreate operation, setEdoc operation, setLinks operation, etc..) objects, which contain information about any errors that may have occurred during the creation. As long as the entryCreate operation succeeds, the entry will be created, even if all other operations fail.",
        "operationId": "ImportDocument",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "parentEntryId",
            "in": "path",
            "required": true,
            "description": "The entry ID of the folder that the document will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "fileName",
            "in": "path",
            "required": true,
            "description": "The created document's file name.",
            "schema": {
              "type": "string"
            },
            "x-position": 3
          },
          {
            "name": "autoRename",
            "in": "query",
            "description": "An optional query parameter used to indicate if the new document should be automatically\n            renamed if an entry already exists with the given name in the folder. The default value is false.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 4
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used.\n            The value should be a standard language tag. This may be used when setting field values with tokens.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "electronicDocument": {
                    "type": "string",
                    "format": "binary"
                  },
                  "request": {
                    "$ref": "#/components/schemas/PostEntryWithEdocMetadataRequest"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Document creation is success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateEntryResult"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateEntryResult"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Parent entry is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateEntryResult"
                }
              }
            }
          },
          "409": {
            "description": "Document creation is partial success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateEntryResult"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "Document creation is complete failure.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateEntryResult"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Attributes": {
      "get": {
        "tags": [
          "Attributes"
        ],
        "summary": "Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the \"Everyone\" group. Attribute keys can be used with subsequent calls to get specific attribute values. Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer. Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the \"Everyone\" group. Note when this is true, the response does not include both the \"Everyone\" groups attribute and the currently authenticated user, but only the \"Everyone\" groups.",
        "description": "- Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the \"Everyone\" group.\n- Attribute keys can be used with subsequent calls to get specific attribute values.\n- Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer. Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the \"Everyone\" group. Note when this is true, the response does not include both the \"Everyone\" groups attribute and the currently authenticated user, but only the \"Everyone\" groups.",
        "operationId": "GetTrusteeAttributeKeyValuePairs",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "everyone",
            "in": "query",
            "description": "Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "Get trustee attribute key value pairs successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfListOfAttribute"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Attributes/{attributeKey}": {
      "get": {
        "tags": [
          "Attributes"
        ],
        "summary": "Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within \"Everyone\" group. Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.",
        "description": "- Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within \"Everyone\" group.\n- Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.",
        "operationId": "GetTrusteeAttributeValueByKey",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "attributeKey",
            "in": "path",
            "required": true,
            "description": "The requested attribute key.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "everyone",
            "in": "query",
            "description": "Boolean value that indicates whether to return attributes associated with everyone or the currently authenticated user.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "Get trustee attribute value successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Attribute"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested attribute key not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/FieldDefinitions/{fieldDefinitionId}": {
      "get": {
        "tags": [
          "FieldDefinitions"
        ],
        "summary": "Returns a single field definition associated with the specified ID.  Useful when a route provides a minimal amount of details and more information about the specific field definition is needed. Allowed OData query options: Select",
        "description": "- Returns a single field definition associated with the specified ID. \n- Useful when a route provides a minimal amount of details and more information about the specific field definition is needed.\n- Allowed OData query options: Select",
        "operationId": "GetFieldDefinitionById",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "fieldDefinitionId",
            "in": "path",
            "required": true,
            "description": "The requested field definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "responses": {
          "200": {
            "description": "Get field definition successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WFieldInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested field definition id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/FieldDefinitions": {
      "get": {
        "tags": [
          "FieldDefinitions"
        ],
        "summary": "Returns a paged listing of field definitions available in the specified repository. Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns a paged listing of field definitions available in the specified repository.\n- Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetFieldDefinitions",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "Get field definitions successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfWFieldInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/LinkDefinitions": {
      "get": {
        "tags": [
          "LinkDefinitions"
        ],
        "summary": "Returns the link definitions in the repository. Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns the link definitions in the repository.\n- Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetLinkDefinitions",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 6
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 8
          }
        ],
        "responses": {
          "200": {
            "description": "Get link definitions successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfEntryLinkTypeInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/LinkDefinitions/{linkTypeId}": {
      "get": {
        "tags": [
          "LinkDefinitions"
        ],
        "summary": "Returns a single link definition associated with the specified ID. Provide a link type ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed. Allowed OData query options: Select",
        "description": "- Returns a single link definition associated with the specified ID.\n- Provide a link type ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed.\n- Allowed OData query options: Select",
        "operationId": "GetLinkDefinitionById",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "linkTypeId",
            "in": "path",
            "required": true,
            "description": "The requested link type ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "Get link definition successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryLinkTypeInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested link type definition ID not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns a single entry object. Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc. Allowed OData query options: Select. If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.",
        "description": "- Returns a single entry object.\n- Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc.\n- Allowed OData query options: Select. If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.",
        "operationId": "GetEntry",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "Get entry successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Begins a task to delete an entry, and returns an operationToken. Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately. Optionally include an audit reason ID and comment in the JSON body. This route returns an operationToken, and will run as an asynchronous operation. Check the progress via the Tasks/{operationToken} route.",
        "description": "- Begins a task to delete an entry, and returns an operationToken.\n- Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately.\n- Optionally include an audit reason ID and comment in the JSON body. This route returns an operationToken, and will run as an asynchronous operation. Check the progress via the Tasks/{operationToken} route.",
        "operationId": "DeleteEntryInfo",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The submitted audit reason.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteEntryWithAuditReason"
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "201": {
            "description": "Delete entry operation start successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedOperation"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Entries"
        ],
        "summary": "Moves and/or renames an entry. Move and/or rename an entry by passing in the new parent folder ID or name in the JSON body. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.",
        "description": "- Moves and/or renames an entry.\n- Move and/or rename an entry by passing in the new parent folder ID or name in the JSON body.\n- Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.",
        "operationId": "MoveOrRenameEntry",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "autoRename",
            "in": "query",
            "description": "An optional query parameter used to indicate if the entry should be automatically\n            renamed if another entry already exists with the same name in the folder. The default value is false.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 4
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The request containing the folder ID that the entry will be moved to and the new name\n            the entry will be renamed to.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchEntryRequest"
              },
              "examples": {
                "1": {
                  "summary": "Move an entry",
                  "description": "We can move an entry by specifying the parent folder id in the request body.",
                  "value": {
                    "parentId": 123
                  }
                },
                "2": {
                  "summary": "Rename an entry",
                  "description": "We can rename an entry by specifying the new name of the entry in the request body.",
                  "value": {
                    "name": "NewName"
                  }
                },
                "3": {
                  "summary": "Move and Rename an entry",
                  "description": "We can move and rename an entry by specifying the parent folder id and the new name of the entry in the request body.",
                  "value": {
                    "parentId": 123,
                    "name": "NewName"
                  }
                }
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "Moves and/or renames an entry successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "409": {
            "description": "Entry name conflicts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/ByPath": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns a single entry object using the entry path. Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.",
        "description": "- Returns a single entry object using the entry path.\n- Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.",
        "operationId": "GetEntryByPath",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "fullPath",
            "in": "query",
            "required": true,
            "description": "The requested entry path.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "fallbackToClosestAncestor",
            "in": "query",
            "description": "An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "Get entry successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FindEntryResult"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested entry path not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/children": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the children entries of a folder in the repository. Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: \"PropertyName direction,PropertyName2 direction\". Sort order can be either value \"asc\" or \"desc\". Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route. Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.",
        "description": "- Returns the children entries of a folder in the repository.\n- Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: \"PropertyName direction,PropertyName2 direction\". Sort order can be either value \"asc\" or \"desc\". Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route.\n- Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names.\n- If field values are requested, only the first value is returned if it is a multi value field.\n- Null or Empty field values should not be used to determine if a field is assigned to the entry.",
        "operationId": "GetEntryListing",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The folder ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "groupByEntryType",
            "in": "query",
            "description": "An optional query parameter used to indicate if the result should be grouped by entry type or not.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 3
          },
          {
            "name": "fields",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "Optional array of field names. Field values corresponding to the given field names will be returned for each entry. ",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 4
          },
          {
            "name": "formatFields",
            "in": "query",
            "description": "Boolean for if field values should be formatted. Only applicable if Fields are specified.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 5
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise\n            culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 8
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 10
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 11
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 12
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 13
          }
        ],
        "responses": {
          "200": {
            "description": "Get the children entries of a Folder successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfEntry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Create/copy a new child entry in the designated folder. Provide the parent folder ID, and based on the request body, copy or create a folder/shortcut as a child entry of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.",
        "description": "- Create/copy a new child entry in the designated folder.\n- Provide the parent folder ID, and based on the request body, copy or create a folder/shortcut as a child entry of the designated folder.\n- Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.",
        "operationId": "CreateOrCopyEntry",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The folder ID that the entry will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "autoRename",
            "in": "query",
            "description": "An optional query parameter used to indicate if the new entry should be automatically\n            renamed if an entry already exists with the given name in the folder. The default value is false.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 4
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The entry to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PostEntryChildrenRequest"
              },
              "examples": {
                "1": {
                  "summary": "Create a folder",
                  "description": "We can create a new folder with the given name.",
                  "value": {
                    "entryType": "Folder",
                    "name": "NewFolder"
                  }
                },
                "2": {
                  "summary": "Create a shortcut",
                  "description": "We can create a new shortcut with the given name to the entry with the targetId.",
                  "value": {
                    "entryType": "Shortcut",
                    "name": "NewShortcut",
                    "targetId": 123
                  }
                },
                "3": {
                  "summary": "Copy an entry",
                  "description": "We can copy an entry (marked by sourceId property) to a destination (marked in URL).",
                  "value": {
                    "sourceId": 123,
                    "name": "CopiedEntry"
                  }
                }
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "201": {
            "description": "Created a new child entry successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "409": {
            "description": "Entry name conflicts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/fields": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the fields assigned to an entry. Provide an entry ID, and get a paged listing of all fields assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns the fields assigned to an entry.\n- Provide an entry ID, and get a paged listing of all fields assigned to that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetFieldValues",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "formatValue",
            "in": "query",
            "description": "An optional query parameter used to indicate if the field values should be formatted.\n            The default value is false.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-position": 4
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag. The formatValue query parameter must be set to true, otherwise\n            culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 8
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 10
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 11
          }
        ],
        "responses": {
          "200": {
            "description": "Get field values successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfFieldValue"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Update the field values assigned to an entry. Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.  This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.",
        "description": "- Update the field values assigned to an entry.\n- Provide the new field values to assign to the entry, and remove/reset all previously assigned field values. \n- This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.",
        "operationId": "AssignFieldValues",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The entry ID of the entry that will have its fields updated.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used.\n            The value should be a standard language tag. This may be used when setting field values with tokens.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "fieldsToUpdate",
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/FieldToUpdate"
                }
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "Update field values successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfIListOfFieldValue"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Requested entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/tags": {
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the tags assigned to an entry. Provide an entry ID, and get a paged listing of tags assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns the tags assigned to an entry.\n- Provide an entry ID, and get a paged listing of tags assigned to that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetTagsAssignedToEntry",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "Get entry tags successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfWTagInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Assign tags to an entry. Provide an entry ID and a list of tags to assign to that entry. This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.",
        "description": "- Assign tags to an entry.\n- Provide an entry ID and a list of tags to assign to that entry.\n- This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.",
        "operationId": "AssignTags",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "tagsToAdd",
          "description": "The tags to add.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PutTagRequest"
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "Assign tags to an entry successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfIListOfWTagInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/links": {
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Assign links to an entry. Provide an entry ID and a list of links to assign to that entry. This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.",
        "description": "- Assign links to an entry.\n- Provide an entry ID and a list of links to assign to that entry.\n- This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.",
        "operationId": "AssignEntryLinks",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The request repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "linksToAdd",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/PutLinksRequest"
                }
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "Assign links to an entry successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfIListOfWEntryLinkInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns the links assigned to an entry. Provide an entry ID, and get a paged listing of links assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns the links assigned to an entry.\n- Provide an entry ID, and get a paged listing of links assigned to that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetLinkValuesFromEntry",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "Get links successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfWEntryLinkInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/CopyAsync": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Copy a new child entry in the designated folder async, and potentially return an operationToken. Provide the parent folder ID, and copy an entry as a child of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.  The status of the operation can be checked via the Tasks/{operationToken} route.",
        "description": "- Copy a new child entry in the designated folder async, and potentially return an operationToken.\n- Provide the parent folder ID, and copy an entry as a child of the designated folder.\n- Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed. \n- The status of the operation can be checked via the Tasks/{operationToken} route.",
        "operationId": "CopyEntryAsync",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The folder ID that the entry will be created in.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "autoRename",
            "in": "query",
            "description": "An optional query parameter used to indicate if the new entry should be automatically\n            renamed if an entry already exists with the given name in the folder. The default value is false.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 4
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "Copy entry request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CopyAsyncRequest"
              },
              "examples": {
                "1": {
                  "summary": "Copy an entry",
                  "description": "We can copy an entry (marked by sourceId property) to a destination (marked in URL).",
                  "value": {
                    "sourceId": 123,
                    "name": "CopiedEntry"
                  }
                }
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "201": {
            "description": "Copy entry operation is started successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedOperation"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/edoc": {
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Delete the edoc associated with the provided entry ID.",
        "description": "- Delete the edoc associated with the provided entry ID.",
        "operationId": "DeleteDocument",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested document ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted edoc successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfBoolean"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "head": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns information about the edoc content of an entry, without downloading the edoc in its entirety. Provide an entry ID, and get back the Content-Type and Content-Length in the response headers. This route does not provide a way to download the actual edoc. Instead, it just gives metadata information about the edoc associated with the entry.",
        "description": "- Returns information about the edoc content of an entry, without downloading the edoc in its entirety.\n- Provide an entry ID, and get back the Content-Type and Content-Length in the response headers.\n- This route does not provide a way to download the actual edoc. Instead, it just gives metadata information about the edoc associated with the entry.",
        "operationId": "GetDocumentContentType",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested document ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "Get edoc info successfully."
          },
          "400": {
            "description": "Invalid or bad request."
          },
          "401": {
            "description": "Access token is invalid or expired."
          },
          "403": {
            "description": "Access denied for the operation."
          },
          "404": {
            "description": "Request entry id not found."
          },
          "423": {
            "description": "Entry is locked."
          },
          "429": {
            "description": "Rate limit is reached."
          }
        }
      },
      "get": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns an entry's edoc resource in a stream format. Provide an entry ID, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc.",
        "description": "- Returns an entry's edoc resource in a stream format.\n- Provide an entry ID, and get the edoc resource as part of the response content.\n- Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc.",
        "operationId": "ExportDocument",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested document ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Range",
            "x-originalName": "range",
            "in": "header",
            "description": "An optional header used to retrieve partial content of the edoc. Only supports single\n            range with byte unit.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "Get edoc successfully.",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "206": {
            "description": "Get edoc range successfully.",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/pages": {
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted. Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: \"1,2,3\", \"1-3,5\", \"2-7,10-12.\"",
        "description": "- Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted.\n- Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: \"1,2,3\", \"1-3,5\", \"2-7,10-12.\"",
        "operationId": "DeletePages",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested document ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "pageRange",
            "in": "query",
            "description": "The pages to be deleted.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted pages successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfBoolean"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/GetEdocWithAuditReason": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns an entry's edoc resource in a stream format while including an audit reason. Provide an entry ID and audit reason/comment in the request body, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc. This route is identical to the GET edoc route, but allows clients to include an audit reason when downloading the edoc.",
        "description": "- Returns an entry's edoc resource in a stream format while including an audit reason.\n- Provide an entry ID and audit reason/comment in the request body, and get the edoc resource as part of the response content.\n- Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc. This route is identical to the GET edoc route, but allows clients to include an audit reason when downloading the edoc.",
        "operationId": "ExportDocumentWithAuditReason",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested document ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Range",
            "x-originalName": "range",
            "in": "header",
            "description": "An optional header used to retrieve partial content of the edoc. Only supports single\n            range with byte unit.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEdocWithAuditReasonRequest"
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "Get edoc successfully.",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "206": {
            "description": "Get edoc range successfully.",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/fields/GetDynamicFieldLogicValue": {
      "post": {
        "tags": [
          "Entries"
        ],
        "summary": "Returns dynamic field logic values with the current values of the fields in the template. Provide an entry ID and field values in the JSON body to get dynamic field logic values.  Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.",
        "description": "- Returns dynamic field logic values with the current values of the fields in the template.\n- Provide an entry ID and field values in the JSON body to get dynamic field logic values.\n Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.",
        "operationId": "GetDynamicFieldValues",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The requested entry ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "requestBody": {
          "x-name": "request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDynamicFieldLogicValueRequest"
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "Get dynamic field logic values successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Entries/{entryId}/template": {
      "delete": {
        "tags": [
          "Entries"
        ],
        "summary": "Remove the currently assigned template from the specified entry. Provide an entry ID to clear template value on. If the entry does not have a template assigned, no change will be made.",
        "description": "- Remove the currently assigned template from the specified entry.\n- Provide an entry ID to clear template value on.\n- If the entry does not have a template assigned, no change will be made.",
        "operationId": "DeleteAssignedTemplate",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The ID of the entry that will have its template removed.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "Remove the currently assigned template successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Entries"
        ],
        "summary": "Assign a template to an entry. Provide an entry ID, template name, and a list of template fields to assign to that entry. Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.",
        "description": "- Assign a template to an entry.\n- Provide an entry ID, template name, and a list of template fields to assign to that entry.\n- Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.",
        "operationId": "WriteTemplateValueToEntry",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "entryId",
            "in": "path",
            "required": true,
            "description": "The ID of entry that will have its template updated.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used.\n            The value should be a standard language tag. This may be used when setting field values with tokens.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The template and template fields that will be assigned to the entry.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PutTemplateRequest"
              },
              "examples": {
                "1": {
                  "summary": "Assign a template for an entry and not assign any field values for it",
                  "description": "We can set the template to an entry using the above request with fields having empty/default values.",
                  "value": {
                    "templateName": "sample template 1"
                  }
                },
                "2": {
                  "summary": "Assign a template with field values for an entry",
                  "description": "If the template contains fields Today and Address, we can set the template to an entry using the above request with specified fields values.",
                  "value": {
                    "templateName": "sample template 2",
                    "fields": {
                      "Today": {
                        "values": [
                          {
                            "value": "2020-02-18T00:00:00",
                            "position": 1
                          }
                        ]
                      },
                      "Address": {
                        "values": [
                          {
                            "value": "3545 Long Beach Blvd. Long Beach CA, 90807 U.S.A.",
                            "position": 1
                          },
                          {
                            "value": "306, 1 Valleybrook Drive North York, Toronto, Ontario M3B2S7 CANADA",
                            "position": 2
                          },
                          {
                            "value": "2307, Westlands Centre 20 Westlands Road Quarry Bay, Hong Kong",
                            "position": 3
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "x-position": 3
        },
        "responses": {
          "200": {
            "description": "Assign a template successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request entry id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "423": {
            "description": "Entry is locked.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories": {
      "get": {
        "tags": [
          "Repositories"
        ],
        "summary": "Returns the repository resource list that current user has access to.",
        "description": "- Returns the repository resource list that current user has access to.",
        "operationId": "GetRepositoryList",
        "responses": {
          "200": {
            "description": "Get the respository resource list successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RepositoryInfo"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/AuditReasons": {
      "get": {
        "tags": [
          "AuditReasons"
        ],
        "summary": "Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included. Only includes audit reasons associated with available API functionalities, like delete entry and export document. If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.",
        "description": "- Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included.\n- Only includes audit reasons associated with available API functionalities, like delete entry and export document.\n- If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.",
        "operationId": "GetAuditReasons",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          }
        ],
        "responses": {
          "200": {
            "description": "Get audit reasons successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditReasons"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Searches": {
      "post": {
        "tags": [
          "Searches"
        ],
        "summary": "Runs a search operation on the repository. Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage). The status for search operations must be checked via the Search specific status checking route.         ",
        "description": "- Runs a search operation on the repository.\n- Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage). The status for search operations must be checked via the Search specific status checking route.         ",
        "operationId": "CreateSearchOperation",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The Laserfiche search command to run, optionally include fuzzy search settings.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdvancedSearchRequest"
              },
              "examples": {
                "1": {
                  "summary": "Run an advanced search with fuzzy type",
                  "description": "Run an advanced search with fuzzy type based on number of letters",
                  "value": {
                    "searchCommand": "({LF:Basic ~= \"search text\", option=\"DFANLT\"})",
                    "fuzzyType": "NumberOfLetters",
                    "fuzzyFactor": 2
                  }
                },
                "2": {
                  "summary": "Run an advanced search with percentage fuzzy type",
                  "description": "Run an advanced search with fuzzy type based on percentage",
                  "value": {
                    "searchCommand": "({LF:Basic ~= \"search text\", option=\"DFANLT\"})",
                    "fuzzyType": "Percentage",
                    "fuzzyFactor": 80
                  }
                }
              }
            }
          },
          "x-position": 2
        },
        "responses": {
          "201": {
            "description": "Search operation start successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedOperation"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Searches/{searchToken}": {
      "get": {
        "tags": [
          "Searches"
        ],
        "summary": "Returns search status. Provide a token (returned in the create search asynchronous route), and get the search status, progress, and any errors that may have occurred. When the search is completed, the Location header can be inspected as a link to the search results. OperationStatus can be one of the following : NotStarted, InProgress, Completed, Failed, or Canceled.",
        "description": "- Returns search status.\n- Provide a token (returned in the create search asynchronous route), and get the search status, progress, and any errors that may have occurred. When the search is completed, the Location header can be inspected as a link to the search results.\n- OperationStatus can be one of the following : NotStarted, InProgress, Completed, Failed, or Canceled.",
        "operationId": "GetSearchStatus",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "searchToken",
            "in": "path",
            "required": true,
            "description": "The requested searchToken.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "Search has failed. Check the errors property to find out why.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OperationProgress"
                }
              }
            }
          },
          "201": {
            "description": "Search is completed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OperationProgress"
                }
              }
            }
          },
          "202": {
            "description": "Search is still in progress or not started.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OperationProgress"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request search token not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Searches"
        ],
        "summary": "Cancels a currently running search. Closes a completed search.",
        "description": "- Cancels a currently running search.\n- Closes a completed search.",
        "operationId": "CancelOrCloseSearch",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "searchToken",
            "in": "path",
            "required": true,
            "description": "The requested searchToken.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "Cancel or closed search successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfBoolean"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request search token not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Searches/{searchToken}/Results": {
      "get": {
        "tags": [
          "Searches"
        ],
        "summary": "Returns a search result listing if the search is completed. Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type. Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values. Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: \"PropertyName direction,PropertyName2 direction\". sort order can be either \"asc\" or \"desc\". Search results expire after 5 minutes, but can be refreshed by retrieving the results again. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.",
        "description": "- Returns a search result listing if the search is completed.\n- Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type.\n- Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values.\n- Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: \"PropertyName direction,PropertyName2 direction\". sort order can be either \"asc\" or \"desc\". Search results expire after 5 minutes, but can be refreshed by retrieving the results again.\n- Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names.\n- If field values are requested, only the first value is returned if it is a multi value field.\n- Null or Empty field values should not be used to determine if a field is assigned to the entry.",
        "operationId": "GetSearchResults",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "searchToken",
            "in": "path",
            "required": true,
            "description": "The requested searchToken.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "groupByEntryType",
            "in": "query",
            "description": "An optional query parameter used to indicate if the result should be grouped by entry type or not.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 3
          },
          {
            "name": "refresh",
            "in": "query",
            "description": "If the search listing should be refreshed to show updated values.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 4
          },
          {
            "name": "fields",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "Optional array of field names. Field values corresponding to the given field names will be returned for each search result. ",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 5
          },
          {
            "name": "formatFields",
            "in": "query",
            "description": "Boolean for if field values should be formatted. Only applicable if Fields are specified.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 6
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise\n            culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 8
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 9
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 11
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 12
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 13
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 14
          }
        ],
        "responses": {
          "200": {
            "description": "Get search result successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfEntry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request search token not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Searches/{searchToken}/Results/{rowNumber}/ContextHits": {
      "get": {
        "tags": [
          "Searches"
        ],
        "summary": "Returns the context hits associated with a search result entry. Given a searchToken, and rowNumber associated with a search entry in the listing, return the context hits for that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns the context hits associated with a search result entry.\n- Given a searchToken, and rowNumber associated with a search entry in the listing, return the context hits for that entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetSearchContextHits",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "searchToken",
            "in": "path",
            "required": true,
            "description": "The requested searchToken.",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          },
          {
            "name": "rowNumber",
            "in": "path",
            "required": true,
            "description": "The search result listing row number to get context hits for.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 3
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "Get search context hits successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfContextHit"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request search token not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/SimpleSearches": {
      "post": {
        "tags": [
          "SimpleSearches"
        ],
        "summary": "Runs a \"simple\" search operation on the repository. Returns a truncated search result listing. Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.",
        "description": "- Runs a \"simple\" search operation on the repository.\n- Returns a truncated search result listing.\n- Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches.\n- Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names.\n- If field values are requested, only the first value is returned if it is a multi value field.\n- Null or Empty field values should not be used to determine if a field is assigned to the entry.",
        "operationId": "CreateSimpleSearchOperation",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "fields",
            "in": "query",
            "style": "form",
            "explode": true,
            "description": "Optional array of field names. Field values corresponding to the given field names will be returned for each search result. ",
            "schema": {
              "type": "array",
              "nullable": true,
              "items": {
                "type": "string"
              }
            },
            "x-position": 2
          },
          {
            "name": "formatFields",
            "in": "query",
            "description": "Boolean for if field values should be formatted. Only applicable if Fields are specified.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise\n            culture will not be used for formatting.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "x-name": "request",
          "description": "The Laserfiche search command to run.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SimpleSearchRequest"
              },
              "examples": {
                "1": {
                  "summary": "Run a search",
                  "description": "Run a simple search with LF search command. The \" in search command needs to be escaped.",
                  "value": {
                    "searchCommand": "({LF:Basic ~= \"search text\", option=\"DFANLT\"})"
                  }
                }
              }
            }
          },
          "x-position": 4
        },
        "responses": {
          "200": {
            "description": "Simple search run successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfEntry"
                }
              }
            }
          },
          "204": {
            "description": "No search results found."
          },
          "206": {
            "description": "There are more search results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfEntry"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Operation limit or request limit reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/TagDefinitions": {
      "get": {
        "tags": [
          "TagDefinitions"
        ],
        "summary": "Returns all tag definitions in the repository. Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns all tag definitions in the repository.\n- Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetTagDefinitions",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 6
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 7
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 9
          }
        ],
        "responses": {
          "200": {
            "description": "Get tag definitions successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfWTagInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/TagDefinitions/{tagId}": {
      "get": {
        "tags": [
          "TagDefinitions"
        ],
        "summary": "Returns a single tag definition. Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed. Allowed OData query options: Select",
        "description": "- Returns a single tag definition.\n- Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed.\n- Allowed OData query options: Select",
        "operationId": "GetTagDefinitionById",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "tagId",
            "in": "path",
            "required": true,
            "description": "The requested tag definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "responses": {
          "200": {
            "description": "Get tag definition successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WTagInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request tag definition id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/Tasks/{operationToken}": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Returns the status of an operation. Provide an operationToken (returned in other asynchronous routes) to get the operation status, progress, and any errors that may have occurred. When the operation is completed, the Location header can be inspected as a link to the modified resources (if relevant). OperationStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.",
        "description": "- Returns the status of an operation.\n- Provide an operationToken (returned in other asynchronous routes) to get the operation status, progress, and any errors that may have occurred. When the operation is completed, the Location header can be inspected as a link to the modified resources (if relevant).\n- OperationStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.",
        "operationId": "GetOperationStatusAndProgress",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "operationToken",
            "in": "path",
            "required": true,
            "description": "The operation token",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "200": {
            "description": "Get completed or failed operation status with no result successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OperationProgress"
                }
              }
            }
          },
          "201": {
            "description": "Get completed operation status with operation result url in Location header.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OperationProgress"
                }
              }
            }
          },
          "202": {
            "description": "Get not started or in progress operation status successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OperationProgress"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request operationToken not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Tasks"
        ],
        "summary": "Cancels an operation. Provide an operationToken to cancel the operation, if possible. Should be used if an operation was created in error, or is no longer necessary. Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.",
        "description": "- Cancels an operation.\n- Provide an operationToken to cancel the operation, if possible. Should be used if an operation was created in error, or is no longer necessary.\n- Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.",
        "operationId": "CancelOperation",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "operationToken",
            "in": "path",
            "required": true,
            "description": "The operation token",
            "schema": {
              "type": "string"
            },
            "x-position": 2
          }
        ],
        "responses": {
          "204": {
            "description": "Cancel operation successfully."
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request operationToken not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/TemplateDefinitions": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned. Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned.\n- Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one.\n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetTemplateDefinitions",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateName",
            "in": "query",
            "description": "An optional query parameter. Can be used to get a single template definition using the template name.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "Get template definitions successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfWTemplateInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template name not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/TemplateDefinitions/{templateId}": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns a single template definition (including field definitions, if relevant). Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed. Allowed OData query options: Select",
        "description": "- Returns a single template definition (including field definitions, if relevant).\n- Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed.\n- Allowed OData query options: Select",
        "operationId": "GetTemplateDefinitionById",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateId",
            "in": "path",
            "required": true,
            "description": "The requested template definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 4
          }
        ],
        "responses": {
          "200": {
            "description": "Get template definition successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WTemplateInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/TemplateDefinitions/{templateId}/Fields": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns the field definitions assigned to a template definition. Provide a template definition ID, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns the field definitions assigned to a template definition.\n- Provide a template definition ID, and get a paged listing of the field definitions assigned to that template. \n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetTemplateFieldDefinitions",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateId",
            "in": "path",
            "required": true,
            "description": "The requested template definition ID.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "Get template field definitions successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfTemplateFieldInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template id not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/TemplateDefinitions/Fields": {
      "get": {
        "tags": [
          "TemplateDefinitions"
        ],
        "summary": "Returns the field definitions assigned to a template definition. Provide a template definition name, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "description": "- Returns the field definitions assigned to a template definition.\n- Provide a template definition name, and get a paged listing of the field definitions assigned to that template. \n- Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.",
        "operationId": "GetTemplateFieldDefinitionsByTemplateName",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          },
          {
            "name": "templateName",
            "in": "query",
            "required": true,
            "description": "A required query parameter for the requested template name.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 2
          },
          {
            "name": "Prefer",
            "x-originalName": "prefer",
            "in": "header",
            "description": "An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 3
          },
          {
            "name": "culture",
            "in": "query",
            "description": "An optional query parameter used to indicate the locale that should be used for formatting.\n            The value should be a standard language tag.",
            "schema": {
              "type": "string",
              "default": "",
              "nullable": true
            },
            "x-position": 4
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Limits the properties returned in the result.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 5
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "Specifies the order in which items are returned. The maximum number of expressions is 5.",
            "schema": {
              "type": "string",
              "nullable": true
            },
            "x-position": 7
          },
          {
            "name": "$top",
            "in": "query",
            "description": "Limits the number of items returned from a collection.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 8
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "Excludes the specified number of items of the queried collection from the result.",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-position": 9
          },
          {
            "name": "$count",
            "in": "query",
            "description": "Indicates whether the total count of items within a collection are returned in the result.",
            "schema": {
              "type": "boolean"
            },
            "x-position": 10
          }
        ],
        "responses": {
          "200": {
            "description": "Get template field definitions successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueContextOfIListOfTemplateFieldInfo"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Request template name not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/v1/Repositories/{repoId}/ServerSession/Invalidate": {
      "post": {
        "tags": [
          "ServerSession"
        ],
        "summary": "Deprecated. Invalidates the server session. Acts as a \"logout\" operation, and invalidates the session associated with the provided access token. This method should be used when the client wants to clean up the current session. Only available in Laserfiche Cloud.",
        "description": "- Deprecated.\n- Invalidates the server session.\n- Acts as a \"logout\" operation, and invalidates the session associated with the provided access token. This method should be used when the client wants to clean up the current session.\n- Only available in Laserfiche Cloud.",
        "operationId": "InvalidateServerSession",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          }
        ],
        "responses": {
          "200": {
            "description": "Invalidate the server session successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfBoolean"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/v1/Repositories/{repoId}/ServerSession/Refresh": {
      "post": {
        "tags": [
          "ServerSession"
        ],
        "summary": "Deprecated. Refreshes the session associated with the access token. This is only necessary if you want to keep the same session alive, otherwise a new session will be automatically created when the session expires. When a client application wants to keep a session alive that has been idle for an hour, this route can be used to refresh the expiration timer associated with the access token. Only available in Laserfiche Cloud.",
        "description": "- Deprecated.\n- Refreshes the session associated with the access token. This is only necessary if you want to keep the same session alive, otherwise a new session will be automatically created when the session expires.\n- When a client application wants to keep a session alive that has been idle for an hour, this route can be used to refresh the expiration timer associated with the access token.\n- Only available in Laserfiche Cloud.",
        "operationId": "RefreshServerSession",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          }
        ],
        "responses": {
          "200": {
            "description": "Refresh the session successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfDateTime"
                }
              }
            }
          },
          "400": {
            "description": "Invalid or bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit is reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/v1/Repositories/{repoId}/ServerSession/Create": {
      "post": {
        "tags": [
          "ServerSession"
        ],
        "summary": "Deprecated. This function is a no-op, always returns 200. Only available in Laserfiche Cloud.",
        "description": "- Deprecated. This function is a no-op, always returns 200.\n- Only available in Laserfiche Cloud.",
        "operationId": "CreateServerSession",
        "parameters": [
          {
            "name": "repoId",
            "in": "path",
            "required": true,
            "description": "The requested repository ID.",
            "schema": {
              "type": "string"
            },
            "x-position": 1
          }
        ],
        "responses": {
          "200": {
            "description": "Create the session successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ODataValueOfBoolean"
                }
              }
            }
          },
          "401": {
            "description": "Access token is invalid or expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Access denied for the operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    }
  },
  "components": {
    "schemas": {
      "CreateEntryResult": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "operations": {
            "$ref": "#/components/schemas/CreateEntryOperations"
          },
          "documentLink": {
            "type": "string",
            "description": "A link to get the created entry.",
            "nullable": true
          }
        }
      },
      "CreateEntryOperations": {
        "type": "object",
        "description": "The results of each operation needed in order to create the electronic document with optional template and fields.",
        "additionalProperties": false,
        "properties": {
          "entryCreate": {
            "$ref": "#/components/schemas/EntryCreate"
          },
          "setEdoc": {
            "$ref": "#/components/schemas/SetEdoc"
          },
          "setTemplate": {
            "$ref": "#/components/schemas/SetTemplate"
          },
          "setFields": {
            "$ref": "#/components/schemas/SetFields"
          },
          "setTags": {
            "$ref": "#/components/schemas/SetTags"
          },
          "setLinks": {
            "$ref": "#/components/schemas/SetLinks"
          }
        }
      },
      "EntryCreate": {
        "type": "object",
        "description": "The result of trying to create the entry.",
        "additionalProperties": false,
        "properties": {
          "exceptions": {
            "type": "array",
            "description": "The list of exceptions that occured when trying to perform the operation.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/APIServerException"
            }
          },
          "entryId": {
            "type": "integer",
            "description": "The id of the created entry. If the id is 0, then the entry was not created.",
            "format": "int32"
          }
        }
      },
      "APIServerException": {
        "type": "object",
        "properties": {
          "operationId": {
            "type": "string",
            "description": "The id of the operation that threw the exception.",
            "nullable": true
          },
          "message": {
            "type": "string",
            "description": "The explaination of the exception that occurred.",
            "nullable": true
          },
          "errorCode": {
            "type": "integer",
            "description": "The code associated with the exception.",
            "format": "int32",
            "nullable": true
          },
          "errorClass": {
            "type": "string",
            "description": "The class of exceptions this belongs to.",
            "nullable": true
          },
          "statusCode": {
            "type": "integer",
            "description": "The HTTP status code returned.",
            "format": "int32",
            "nullable": true
          },
          "errorSource": {
            "type": "string",
            "description": "The source of where the exception occurred.",
            "nullable": true
          }
        }
      },
      "SetEdoc": {
        "type": "object",
        "description": "The result of trying to create the electronic document.",
        "additionalProperties": false,
        "properties": {
          "exceptions": {
            "type": "array",
            "description": "The list of exceptions that occured when trying to perform the operation.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/APIServerException"
            }
          }
        }
      },
      "SetTemplate": {
        "type": "object",
        "description": "The result of trying to assign a template to the entry.",
        "additionalProperties": false,
        "properties": {
          "exceptions": {
            "type": "array",
            "description": "The list of exceptions that occured when trying to perform the operation.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/APIServerException"
            }
          },
          "template": {
            "type": "string",
            "description": "The name of the template assigned to the entry. If this is null, then no template was assigned.",
            "nullable": true
          }
        }
      },
      "SetFields": {
        "type": "object",
        "description": "The result of trying to assign fields to the entry.",
        "additionalProperties": false,
        "properties": {
          "exceptions": {
            "type": "array",
            "description": "The list of exceptions that occured when trying to perform the operation.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/APIServerException"
            }
          },
          "fieldCount": {
            "type": "integer",
            "description": "The number of fields assigned to the entry.",
            "format": "int32"
          }
        }
      },
      "SetTags": {
        "type": "object",
        "description": "The result of trying to assign fields to the entry.",
        "additionalProperties": false,
        "properties": {
          "exceptions": {
            "type": "array",
            "description": "The list of exceptions that occured when trying to perform the operation.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/APIServerException"
            }
          },
          "assignedTags": {
            "type": "array",
            "description": "The tags that were assigned to the entry",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "SetLinks": {
        "type": "object",
        "description": "The result of trying to assign a entry link to the entry.",
        "additionalProperties": false,
        "properties": {
          "exceptions": {
            "type": "array",
            "description": "The list of exceptions that occured when trying to perform the operation.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/APIServerException"
            }
          },
          "otherEntryIds": {
            "type": "array",
            "description": "The ids of the other entries linked to the entry",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "ProblemDetails": {
        "type": "object",
        "description": "A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807.",
        "additionalProperties": {
          "nullable": true
        },
        "required": [
          "status"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when\ndereferenced, it provide human-readable documentation for the problem type\n(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be\n\"about:blank\".",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence\nof the problem, except for purposes of localization(e.g., using proactive content negotiation;\nsee[RFC7231], Section 3.4).",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "description": "The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.",
            "format": "int32"
          },
          "detail": {
            "type": "string",
            "description": "A human-readable explanation specific to this occurrence of the problem.",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "description": "A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced.",
            "nullable": true
          },
          "operationId": {
            "type": "string",
            "description": "The operation id.",
            "nullable": true
          },
          "errorSource": {
            "type": "string",
            "description": "The error source.",
            "nullable": true
          },
          "errorCode": {
            "type": "integer",
            "description": "The error code.",
            "format": "int32"
          },
          "traceId": {
            "type": "string",
            "description": "The trace id.",
            "nullable": true
          }
        }
      },
      "IHeaderDictionary": {
        "type": "object",
        "x-abstract": true,
        "additionalProperties": false,
        "properties": {
          "Item": {
            "type": "array",
            "items": {}
          },
          "ContentLength": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "Accept": {
            "type": "array",
            "items": {}
          },
          "AcceptCharset": {
            "type": "array",
            "items": {}
          },
          "AcceptEncoding": {
            "type": "array",
            "items": {}
          },
          "AcceptLanguage": {
            "type": "array",
            "items": {}
          },
          "AcceptRanges": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowCredentials": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowHeaders": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowMethods": {
            "type": "array",
            "items": {}
          },
          "AccessControlAllowOrigin": {
            "type": "array",
            "items": {}
          },
          "AccessControlExposeHeaders": {
            "type": "array",
            "items": {}
          },
          "AccessControlMaxAge": {
            "type": "array",
            "items": {}
          },
          "AccessControlRequestHeaders": {
            "type": "array",
            "items": {}
          },
          "AccessControlRequestMethod": {
            "type": "array",
            "items": {}
          },
          "Age": {
            "type": "array",
            "items": {}
          },
          "Allow": {
            "type": "array",
            "items": {}
          },
          "AltSvc": {
            "type": "array",
            "items": {}
          },
          "Authorization": {
            "type": "array",
            "items": {}
          },
          "Baggage": {
            "type": "array",
            "items": {}
          },
          "CacheControl": {
            "type": "array",
            "items": {}
          },
          "Connection": {
            "type": "array",
            "items": {}
          },
          "ContentDisposition": {
            "type": "array",
            "items": {}
          },
          "ContentEncoding": {
            "type": "array",
            "items": {}
          },
          "ContentLanguage": {
            "type": "array",
            "items": {}
          },
          "ContentLocation": {
            "type": "array",
            "items": {}
          },
          "ContentMD5": {
            "type": "array",
            "items": {}
          },
          "ContentRange": {
            "type": "array",
            "items": {}
          },
          "ContentSecurityPolicy": {
            "type": "array",
            "items": {}
          },
          "ContentSecurityPolicyReportOnly": {
            "type": "array",
            "items": {}
          },
          "ContentType": {
            "type": "array",
            "items": {}
          },
          "CorrelationContext": {
            "type": "array",
            "items": {}
          },
          "Cookie": {
            "type": "array",
            "items": {}
          },
          "Date": {
            "type": "array",
            "items": {}
          },
          "ETag": {
            "type": "array",
            "items": {}
          },
          "Expires": {
            "type": "array",
            "items": {}
          },
          "Expect": {
            "type": "array",
            "items": {}
          },
          "From": {
            "type": "array",
            "items": {}
          },
          "GrpcAcceptEncoding": {
            "type": "array",
            "items": {}
          },
          "GrpcEncoding": {
            "type": "array",
            "items": {}
          },
          "GrpcMessage": {
            "type": "array",
            "items": {}
          },
          "GrpcStatus": {
            "type": "array",
            "items": {}
          },
          "GrpcTimeout": {
            "type": "array",
            "items": {}
          },
          "Host": {
            "type": "array",
            "items": {}
          },
          "KeepAlive": {
            "type": "array",
            "items": {}
          },
          "IfMatch": {
            "type": "array",
            "items": {}
          },
          "IfModifiedSince": {
            "type": "array",
            "items": {}
          },
          "IfNoneMatch": {
            "type": "array",
            "items": {}
          },
          "IfRange": {
            "type": "array",
            "items": {}
          },
          "IfUnmodifiedSince": {
            "type": "array",
            "items": {}
          },
          "LastModified": {
            "type": "array",
            "items": {}
          },
          "Link": {
            "type": "array",
            "items": {}
          },
          "Location": {
            "type": "array",
            "items": {}
          },
          "MaxForwards": {
            "type": "array",
            "items": {}
          },
          "Origin": {
            "type": "array",
            "items": {}
          },
          "Pragma": {
            "type": "array",
            "items": {}
          },
          "ProxyAuthenticate": {
            "type": "array",
            "items": {}
          },
          "ProxyAuthorization": {
            "type": "array",
            "items": {}
          },
          "ProxyConnection": {
            "type": "array",
            "items": {}
          },
          "Range": {
            "type": "array",
            "items": {}
          },
          "Referer": {
            "type": "array",
            "items": {}
          },
          "RetryAfter": {
            "type": "array",
            "items": {}
          },
          "RequestId": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketAccept": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketKey": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketProtocol": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketVersion": {
            "type": "array",
            "items": {}
          },
          "SecWebSocketExtensions": {
            "type": "array",
            "items": {}
          },
          "Server": {
            "type": "array",
            "items": {}
          },
          "SetCookie": {
            "type": "array",
            "items": {}
          },
          "StrictTransportSecurity": {
            "type": "array",
            "items": {}
          },
          "TE": {
            "type": "array",
            "items": {}
          },
          "Trailer": {
            "type": "array",
            "items": {}
          },
          "TransferEncoding": {
            "type": "array",
            "items": {}
          },
          "Translate": {
            "type": "array",
            "items": {}
          },
          "TraceParent": {
            "type": "array",
            "items": {}
          },
          "TraceState": {
            "type": "array",
            "items": {}
          },
          "Upgrade": {
            "type": "array",
            "items": {}
          },
          "UpgradeInsecureRequests": {
            "type": "array",
            "items": {}
          },
          "UserAgent": {
            "type": "array",
            "items": {}
          },
          "Vary": {
            "type": "array",
            "items": {}
          },
          "Via": {
            "type": "array",
            "items": {}
          },
          "Warning": {
            "type": "array",
            "items": {}
          },
          "WebSocketSubProtocols": {
            "type": "array",
            "items": {}
          },
          "WWWAuthenticate": {
            "type": "array",
            "items": {}
          },
          "XContentTypeOptions": {
            "type": "array",
            "items": {}
          },
          "XFrameOptions": {
            "type": "array",
            "items": {}
          },
          "XPoweredBy": {
            "type": "array",
            "items": {}
          },
          "XRequestedWith": {
            "type": "array",
            "items": {}
          },
          "XUACompatible": {
            "type": "array",
            "items": {}
          },
          "XXSSProtection": {
            "type": "array",
            "items": {}
          }
        }
      },
      "FieldToUpdate": {
        "type": "object",
        "description": "The request body containing fields that will be assigned to the entry.",
        "additionalProperties": false,
        "properties": {
          "values": {
            "type": "array",
            "description": "The field values that will be assigned to the field.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ValueToUpdate"
            }
          }
        }
      },
      "ValueToUpdate": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "string",
            "description": "The value assigned to the field at the position specified.",
            "nullable": true
          },
          "position": {
            "type": "integer",
            "description": "The position of the value in the field. This is 1-indexed for multi value field. It will be ignored for single value field.",
            "format": "int32"
          }
        }
      },
      "LinkToUpdate": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "linkTypeId": {
            "type": "integer",
            "description": "The id of the link assigned to the entry.",
            "format": "int32"
          },
          "otherSourceId": {
            "type": "integer",
            "description": "The id of the other source linked to the entry.",
            "format": "int32"
          },
          "isSource": {
            "type": "boolean",
            "description": "Whether the entry is the source for the link."
          }
        }
      },
      "PostEntryWithEdocMetadataRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "template": {
            "type": "string",
            "description": "The name of the template assigned to the entry.",
            "nullable": true
          },
          "metadata": {
            "$ref": "#/components/schemas/PutFieldValsRequest"
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "PutFieldValsRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SimpleImportMetadata"
          },
          {
            "type": "object",
            "description": "The request body containing fields that will be assigned to the entry.",
            "additionalProperties": false,
            "properties": {
              "links": {
                "type": "array",
                "description": "The links that will be assigned to the entry.",
                "nullable": true,
                "items": {
                  "$ref": "#/components/schemas/LinkToUpdate"
                }
              }
            }
          }
        ]
      },
      "SimpleImportMetadata": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "fields": {
            "type": "object",
            "description": "The fields that will be assigned to the entry.",
            "nullable": true,
            "additionalProperties": {
              "$ref": "#/components/schemas/FieldToUpdate"
            }
          },
          "tags": {
            "type": "array",
            "description": "The tags that will be assigned to the entry.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ODataValueContextOfListOfAttribute": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfListOfAttribute"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfListOfAttribute": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Attribute"
            }
          }
        }
      },
      "Attribute": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "key": {
            "type": "string",
            "nullable": true
          },
          "value": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "WFieldInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the field.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "The localized name of the field.",
            "nullable": true
          },
          "id": {
            "type": "integer",
            "description": "The ID of the field.",
            "format": "int32"
          },
          "description": {
            "type": "string",
            "description": "The description of the field.",
            "nullable": true
          },
          "fieldType": {
            "description": "The type of the field.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/WFieldType"
              }
            ]
          },
          "length": {
            "type": "integer",
            "description": "The length of the field for variable length data types.",
            "format": "int32"
          },
          "defaultValue": {
            "type": "string",
            "description": "The default value of the field for new entries that are assigned\nto a template the represented field is a member of.",
            "nullable": true
          },
          "isMultiValue": {
            "type": "boolean",
            "description": "A boolean indicating if the represented template field supports multiple values."
          },
          "isRequired": {
            "type": "boolean",
            "description": "A boolean indicating if the represented field must have a value set\non entries assigned to a template that the field is a member of."
          },
          "constraint": {
            "type": "string",
            "description": "The constraint for values stored in the represented field.",
            "nullable": true
          },
          "constraintError": {
            "type": "string",
            "description": "The error string that will be returned when the field constraint\nis violated when setting a value for this field.",
            "nullable": true
          },
          "listValues": {
            "type": "array",
            "description": "The list of items assigned to the represented field.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          },
          "format": {
            "description": "The display format of the represented field.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/WFieldFormat"
              }
            ]
          },
          "currency": {
            "type": "string",
            "description": "The name of the currency that will be using when formatting\nthe represented field when the Format property is set to the\nCurrency member of the WFieldFormat enumeration.",
            "nullable": true
          },
          "formatPattern": {
            "type": "string",
            "description": "The custom format pattern for fields that are configured to\nuse a custom format.",
            "nullable": true
          }
        }
      },
      "WFieldType": {
        "type": "string",
        "description": "Enumeration of Laserfiche template field types.",
        "x-enumNames": [
          "DateTime",
          "Blob",
          "Date",
          "ShortInteger",
          "LongInteger",
          "List",
          "Number",
          "String",
          "Time"
        ],
        "enum": [
          "DateTime",
          "Blob",
          "Date",
          "ShortInteger",
          "LongInteger",
          "List",
          "Number",
          "String",
          "Time"
        ]
      },
      "WFieldFormat": {
        "type": "string",
        "description": "Enumeration of Laserfiche template field formats.",
        "x-enumNames": [
          "None",
          "ShortDate",
          "LongDate",
          "ShortDateTime",
          "LongDateTime",
          "ShortTime",
          "LongTime",
          "GeneralNumber",
          "Currency",
          "Percent",
          "Scientific",
          "Custom"
        ],
        "enum": [
          "None",
          "ShortDate",
          "LongDate",
          "ShortDateTime",
          "LongDateTime",
          "ShortTime",
          "LongTime",
          "GeneralNumber",
          "Currency",
          "Percent",
          "Scientific",
          "Custom"
        ]
      },
      "ODataValueContextOfIListOfWFieldInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfWFieldInfo"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfWFieldInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WFieldInfo"
            }
          }
        }
      },
      "ODataValueContextOfIListOfEntryLinkTypeInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfEntryLinkTypeInfo"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfEntryLinkTypeInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntryLinkTypeInfo"
            }
          }
        }
      },
      "EntryLinkTypeInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "linkTypeId": {
            "type": "integer",
            "description": "The ID of the entry link type.",
            "format": "int32"
          },
          "sourceLabel": {
            "type": "string",
            "description": "The label for the source entry in the link type.",
            "nullable": true
          },
          "targetLabel": {
            "type": "string",
            "description": "The label for the target entry in the link type.",
            "nullable": true
          },
          "linkTypeDescription": {
            "type": "string",
            "description": "The description of the link type.",
            "nullable": true
          }
        }
      },
      "Entry": {
        "type": "object",
        "x-abstract": true,
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the entry.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The name of the entry.",
            "nullable": true
          },
          "parentId": {
            "type": "integer",
            "description": "The ID of the parent entry.",
            "format": "int32",
            "nullable": true
          },
          "fullPath": {
            "type": "string",
            "description": "The full path in the Laserfiche repository to the entry.",
            "nullable": true
          },
          "folderPath": {
            "type": "string",
            "description": "The path in the Laserfiche repository to the parent folder.",
            "nullable": true
          },
          "creator": {
            "type": "string",
            "description": "The name of the user that created this entry.",
            "nullable": true
          },
          "creationTime": {
            "type": "string",
            "description": "The creation time of the entry.",
            "format": "date-time"
          },
          "lastModifiedTime": {
            "type": "string",
            "description": "The last modification time of the entry.",
            "format": "date-time"
          },
          "entryType": {
            "description": "The type of the entry.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/EntryType"
              }
            ]
          },
          "isContainer": {
            "type": "boolean",
            "description": "A boolean indicating if this entry is a container object; it can have other entries as children."
          },
          "isLeaf": {
            "type": "boolean",
            "description": "A boolean indicating if this entry is a leaf object; it cannot have other entries as children."
          },
          "templateName": {
            "type": "string",
            "description": "The name of the template assigned to this entry.",
            "nullable": true
          },
          "templateId": {
            "type": "integer",
            "description": "The id of the template assigned to this entry.",
            "format": "int32"
          },
          "templateFieldNames": {
            "type": "array",
            "description": "The names of the fields assigned to the template assigned to this entry.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume that this entry is associated with.",
            "nullable": true
          },
          "rowNumber": {
            "type": "integer",
            "description": "Row number assigned to this entry in the listing.",
            "format": "int32"
          },
          "fields": {
            "type": "array",
            "description": "The fields assigned to this entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/EntryFieldValue"
            }
          }
        }
      },
      "EntryType": {
        "type": "string",
        "description": "",
        "x-enumNames": [
          "Folder",
          "RecordSeries",
          "Document",
          "Shortcut"
        ],
        "enum": [
          "Folder",
          "RecordSeries",
          "Document",
          "Shortcut"
        ]
      },
      "EntryFieldValue": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the field.",
            "nullable": true
          },
          "values": {
            "type": "array",
            "description": "The values assigned to the field.",
            "nullable": true,
            "items": {
              "type": "object",
              "additionalProperties": {}
            }
          },
          "fieldType": {
            "description": "The type of the field. The possible field types are listed below.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/WFieldType"
              }
            ]
          },
          "fieldId": {
            "type": "integer",
            "description": "The ID of the field.",
            "format": "int32"
          },
          "isMultiValue": {
            "type": "boolean",
            "description": "A boolean indicating if the represented field supports multiple values."
          },
          "isRequired": {
            "type": "boolean",
            "description": "A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of."
          },
          "hasMoreValues": {
            "type": "boolean",
            "description": "A boolean indicating if there are more field values."
          }
        }
      },
      "RecordSeries": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "additionalProperties": false
          }
        ]
      },
      "Document": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "elecDocumentSize": {
                "type": "integer",
                "description": "The size of the electronic document attached to the represented document,\nif there is one, in bytes.",
                "format": "int64"
              },
              "extension": {
                "type": "string",
                "description": "The extension for the document.",
                "nullable": true
              },
              "isElectronicDocument": {
                "type": "boolean",
                "description": "A boolean indicating if there is an electronic document attached to the represented document."
              },
              "isRecord": {
                "type": "boolean",
                "description": "A boolean indicating if the represented document is a record."
              },
              "mimeType": {
                "type": "string",
                "description": "The MIME type of the electronic document.",
                "nullable": true
              },
              "pageCount": {
                "type": "integer",
                "description": "The page count of the represented document.",
                "format": "int32"
              },
              "isCheckedOut": {
                "type": "boolean",
                "description": "A boolean indicating if the represented document is checked out."
              },
              "isUnderVersionControl": {
                "type": "boolean",
                "description": "A boolean indicating if the represented document is under version control."
              },
              "edoc": {
                "description": "The electronic document attached to the represented document.",
                "nullable": true,
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/Edoc"
                  }
                ]
              }
            }
          }
        ]
      },
      "Edoc": {
        "type": "object",
        "additionalProperties": false
      },
      "Shortcut": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "targetId": {
                "type": "integer",
                "description": "The entry ID of the shortcut target.",
                "format": "int32"
              },
              "extension": {
                "type": "string",
                "description": "The extension of the shortcut target.",
                "nullable": true
              },
              "targetType": {
                "description": "The entry type of the shortcut target.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/EntryType"
                  }
                ]
              }
            }
          }
        ]
      },
      "Folder": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entry"
          },
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "isRecordFolder": {
                "type": "boolean",
                "description": "A boolean indicating if the folder that this instance represents is known\nto be a record folder."
              },
              "isUnderRecordSeries": {
                "type": "boolean",
                "description": "A boolean indicating if the folder that this instance represents is known\nto directly or indirectly under a record series in the repository."
              },
              "children": {
                "type": "array",
                "description": "The entries in this folder.",
                "nullable": true,
                "items": {
                  "$ref": "#/components/schemas/Entry"
                }
              }
            }
          }
        ]
      },
      "FindEntryResult": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "entry": {
            "description": "The entry found by path. This property is set if entry is found.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/Entry"
              }
            ]
          },
          "ancestorEntry": {
            "description": "The closest entry ancestor. This property is set if entry is not found and fallbackToClosestAncestor is set to true.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/Entry"
              }
            ]
          }
        }
      },
      "AcceptedOperation": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "token": {
            "type": "string",
            "description": "A token that can be used to check on the status of the operation.",
            "nullable": true
          }
        }
      },
      "DeleteEntryWithAuditReason": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "auditReasonId": {
            "type": "integer",
            "description": "The reason id for this audit event.",
            "format": "int32",
            "nullable": true
          },
          "comment": {
            "type": "string",
            "description": "The comment for this audit event.",
            "nullable": true
          }
        }
      },
      "PatchEntryRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "parentId": {
            "type": "integer",
            "description": "The ID of the parent entry that the entry will be moved to.",
            "format": "int32",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The name that will be assigned to the entry.",
            "nullable": true
          }
        }
      },
      "ODataValueContextOfIListOfEntry": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfEntry"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfEntry": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Entry"
            }
          }
        }
      },
      "ODataValueContextOfIListOfFieldValue": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfFieldValue"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfFieldValue": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FieldValue"
            }
          }
        }
      },
      "FieldValue": {
        "allOf": [
          {
            "$ref": "#/components/schemas/EntryFieldValue"
          },
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "groupId": {
                "type": "integer",
                "description": "The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id.",
                "format": "int32",
                "nullable": true
              }
            }
          }
        ]
      },
      "ODataValueContextOfIListOfWTagInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfWTagInfo"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfWTagInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WTagInfo"
            }
          }
        }
      },
      "WTagInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the tag definition.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The name of the tag definition.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "The localized name of the tag definition.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The description of the tag definition.",
            "nullable": true
          },
          "isSecure": {
            "type": "boolean",
            "description": "A boolean indicating whether or not the tag definition is classified\nas a security tag (true) or an informational tag (false)."
          },
          "watermark": {
            "description": "The watermark properties associated with the tag definition.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/Watermark"
              }
            ]
          }
        }
      },
      "Watermark": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "watermarkText": {
            "type": "string",
            "description": "The watermark text associated with the tag defintion.",
            "nullable": true
          },
          "watermarkTextSize": {
            "type": "integer",
            "description": "The size of the watermark text, in points, associated with the tag definition.",
            "format": "int32"
          },
          "watermarkPosition": {
            "description": "The position of the watermark on the page.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/WatermarkPosition"
              }
            ]
          },
          "watermarkRotationAngle": {
            "type": "integer",
            "description": "The rotation angle, in degrees, of the watermark associated with the tag definition.",
            "format": "int32"
          },
          "isWatermarkMandatory": {
            "type": "boolean",
            "description": "A boolean indicating whether or not the watermark associated with the tag is mandatory."
          },
          "watermarkIntensity": {
            "type": "integer",
            "description": "The intensity of the watermark associated with the tag definition. Valid value \nranges from 0 to 100, with -1 as the default values.",
            "format": "int32"
          }
        }
      },
      "WatermarkPosition": {
        "type": "string",
        "description": "",
        "x-enumNames": [
          "TopLeft",
          "TopCenter",
          "TopRight",
          "MiddleLeft",
          "DeadCenter",
          "MiddleRight",
          "BottomLeft",
          "BottomCenter",
          "BottomRight"
        ],
        "enum": [
          "TopLeft",
          "TopCenter",
          "TopRight",
          "MiddleLeft",
          "DeadCenter",
          "MiddleRight",
          "BottomLeft",
          "BottomCenter",
          "BottomRight"
        ]
      },
      "PutTagRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "tags": {
            "type": "array",
            "description": "The tag names to assign to the entry.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ODataValueOfIListOfWEntryLinkInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WEntryLinkInfo"
            }
          }
        }
      },
      "WEntryLinkInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "linkId": {
            "type": "integer",
            "description": "The ID of the entry link.",
            "format": "int32"
          },
          "sourceId": {
            "type": "integer",
            "description": "The ID of the source entry of the represented link.",
            "format": "int32"
          },
          "sourceFullPath": {
            "type": "string",
            "description": "The full path to the source entry of the represented link.",
            "nullable": true
          },
          "sourceLabel": {
            "type": "string",
            "description": "The label for the source entry in the link type.",
            "nullable": true
          },
          "targetId": {
            "type": "integer",
            "description": "The ID of the target entry of the represented link.",
            "format": "int32"
          },
          "targetFullPath": {
            "type": "string",
            "description": "The full path to the target entry of the represented link.",
            "nullable": true
          },
          "targetLabel": {
            "type": "string",
            "description": "The label for the target entry in the link type.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The descriptive text for the represented entry link.",
            "nullable": true
          },
          "linkTypeDescription": {
            "type": "string",
            "description": "The description of the link type.",
            "nullable": true
          },
          "linkTypeId": {
            "type": "integer",
            "description": "The ID of the entry link type.",
            "format": "int32"
          },
          "linkProperties": {
            "type": "object",
            "description": "The properties for the entry link.",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            }
          },
          "sourceLink": {
            "type": "string",
            "description": "The navigation link to the source entry.",
            "nullable": true
          },
          "targetLink": {
            "type": "string",
            "description": "The navigation link to the target entry.",
            "nullable": true
          }
        }
      },
      "PutLinksRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "targetId": {
            "type": "integer",
            "description": "The target entry ID to create a link to.",
            "format": "int32"
          },
          "linkTypeId": {
            "type": "integer",
            "description": "The link type ID to create the link with.",
            "format": "int32"
          },
          "customProperties": {
            "type": "object",
            "description": "Custom properties (key, value pairs) to be added to the link",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "ODataValueContextOfIListOfWEntryLinkInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfWEntryLinkInfo"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "PostEntryChildrenRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the entry.",
            "nullable": true
          },
          "entryType": {
            "description": "The type of the entry.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/PostEntryChildrenEntryType"
              }
            ]
          },
          "targetId": {
            "type": "integer",
            "description": "The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target.",
            "format": "int32"
          },
          "sourceId": {
            "type": "integer",
            "description": "The SourceId is needed for some operations that require a source/destination. One example is the Copy operation.",
            "format": "int32"
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "PostEntryChildrenEntryType": {
        "type": "string",
        "description": "",
        "x-enumNames": [
          "Folder",
          "Shortcut"
        ],
        "enum": [
          "Folder",
          "Shortcut"
        ]
      },
      "CopyAsyncRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the entry."
          },
          "sourceId": {
            "type": "integer",
            "description": "The source entry Id to copy.",
            "format": "int32"
          },
          "volumeName": {
            "type": "string",
            "description": "The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud.",
            "nullable": true
          }
        }
      },
      "ODataValueOfBoolean": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "boolean"
          }
        }
      },
      "GetEdocWithAuditReasonRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "auditReasonId": {
            "type": "integer",
            "description": "The reason id for this audit event.",
            "format": "int32",
            "nullable": true
          },
          "comment": {
            "type": "string",
            "description": "The comment for this audit event.",
            "nullable": true
          }
        }
      },
      "GetDynamicFieldLogicValueRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "templateId": {
            "type": "integer",
            "description": "The template id.",
            "format": "int32"
          },
          "fieldValues": {
            "type": "object",
            "description": "The dynamic fields.",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "PutTemplateRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "templateName": {
            "type": "string",
            "description": "The template that will be assigned to the entry.",
            "nullable": true
          },
          "fields": {
            "type": "object",
            "description": "The template fields that will be assigned to the entry.",
            "nullable": true,
            "additionalProperties": {
              "$ref": "#/components/schemas/FieldToUpdate"
            }
          }
        }
      },
      "RepositoryInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "repoId": {
            "type": "string",
            "description": "The repository id.",
            "nullable": true
          },
          "repoName": {
            "type": "string",
            "description": "The repository name.",
            "nullable": true
          },
          "webclientUrl": {
            "type": "string",
            "description": "The corresponding repository WebClient url.",
            "nullable": true
          }
        }
      },
      "AuditReasons": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "deleteEntry": {
            "type": "array",
            "description": "The audit reasons associated with delete entry.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/WAuditReason"
            }
          },
          "exportDocument": {
            "type": "array",
            "description": "The audit reasons associated with export document.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/WAuditReason"
            }
          }
        }
      },
      "WAuditReason": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The audit reason id.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The audit reason text.",
            "nullable": true
          }
        }
      },
      "AdvancedSearchRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "searchCommand": {
            "type": "string",
            "description": "Search command for advanced search",
            "nullable": true
          },
          "fuzzyType": {
            "description": "Fuzzy type (None, Percentage, or NumberOfLetters)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/FuzzyType"
              }
            ]
          },
          "fuzzyFactor": {
            "type": "integer",
            "description": "Fuzzy factor (percentage as int or int value)",
            "format": "int32"
          }
        }
      },
      "FuzzyType": {
        "type": "string",
        "description": "",
        "x-enumNames": [
          "None",
          "Percentage",
          "NumberOfLetters"
        ],
        "enum": [
          "None",
          "Percentage",
          "NumberOfLetters"
        ]
      },
      "OperationProgress": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "operationToken": {
            "type": "string",
            "description": "The operation token of the operation associated with this OperationProgress.",
            "nullable": true
          },
          "operationType": {
            "type": "string",
            "description": "The type of the operation associated with this OperationProgress.",
            "nullable": true
          },
          "percentComplete": {
            "type": "integer",
            "description": "Determines what percentage of the execution of the associated operation is completed.",
            "format": "int32"
          },
          "status": {
            "description": "The status of the operation associated with this OperationProgress.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/OperationStatus"
              }
            ]
          },
          "errors": {
            "type": "array",
            "description": "The list of errors occurred during the execution of the associated operation.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/OperationErrorItem"
            }
          },
          "redirectUri": {
            "type": "string",
            "description": "The URI which can be used (via api call) to access the result(s) of the associated operation.",
            "nullable": true
          },
          "entryId": {
            "type": "integer",
            "description": "The ID of the entry affected (e.g. created or modified) by the execution of the associated operation.",
            "format": "int32"
          },
          "startTimestamp": {
            "type": "string",
            "description": "The timestamp representing when the associated operation's execution is started.",
            "format": "date-time"
          },
          "statusTimestamp": {
            "type": "string",
            "description": "The timestamp representing the last time when the associated task's status has changed.",
            "format": "date-time"
          }
        }
      },
      "OperationStatus": {
        "type": "string",
        "description": "",
        "x-enumNames": [
          "NotStarted",
          "InProgress",
          "Completed",
          "Failed",
          "Cancelled"
        ],
        "enum": [
          "NotStarted",
          "InProgress",
          "Completed",
          "Failed",
          "Cancelled"
        ]
      },
      "OperationErrorItem": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "objectId": {
            "type": "integer",
            "description": "The ID of the entry to which the error is related. ",
            "format": "int32"
          },
          "errorMessage": {
            "type": "string",
            "description": "The short description of the error.",
            "nullable": true
          }
        }
      },
      "ODataValueContextOfIListOfContextHit": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfContextHit"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfContextHit": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContextHit"
            }
          }
        }
      },
      "ContextHit": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "hitType": {
            "$ref": "#/components/schemas/HitType"
          },
          "isAnnotationHit": {
            "type": "boolean",
            "description": "A boolean indicating if this context hit occurs on an annotation."
          },
          "annotationId": {
            "type": "integer",
            "description": "The ID of the annotation that the context hit is in.",
            "format": "int32"
          },
          "pageNumber": {
            "type": "integer",
            "description": "The page number in the document of the search hit's context.",
            "format": "int32"
          },
          "pageOffset": {
            "type": "integer",
            "description": "The offset from the beginning of the page of the starting character of the search hit's context line.",
            "format": "int32"
          },
          "context": {
            "type": "string",
            "description": "The line of context for the search hit.",
            "nullable": true
          },
          "highlight1Offset": {
            "type": "integer",
            "description": "The character offset from the beginning of the context line of the start of the first highlight.",
            "format": "int32"
          },
          "highlight1Length": {
            "type": "integer",
            "description": "The length of the first highlight in characters.",
            "format": "int32"
          },
          "highlight2Offset": {
            "type": "integer",
            "description": "The character offset from the beginning of the context line of the start of the second highlight.",
            "format": "int32"
          },
          "highlight2Length": {
            "type": "integer",
            "description": "The length of the second highlight in characters.",
            "format": "int32"
          },
          "hitWidth": {
            "type": "integer",
            "description": "The number of words in the context hit.",
            "format": "int32"
          },
          "edocHitCount": {
            "type": "integer",
            "description": "The number of hits in the electronic document.",
            "format": "int32"
          },
          "fieldHitCount": {
            "type": "integer",
            "description": "The number of hits in the template.",
            "format": "int32"
          },
          "fieldName": {
            "type": "string",
            "description": "The name of a template field containing the hit.",
            "nullable": true
          },
          "hitNumber": {
            "type": "integer",
            "description": "The hit number.",
            "format": "int32"
          }
        }
      },
      "HitType": {
        "type": "string",
        "description": "The type of context hit.",
        "x-enumNames": [
          "PageContent",
          "Note",
          "Callout",
          "TextBox",
          "Edoc",
          "Prop",
          "Name",
          "Extension",
          "VersionGroupNote",
          "VersionComment",
          "Field",
          "SignatureComment",
          "CertificateSubject",
          "TagComment",
          "AnnotationComment",
          "Attachment"
        ],
        "enum": [
          "PageContent",
          "Note",
          "Callout",
          "TextBox",
          "Edoc",
          "Prop",
          "Name",
          "Extension",
          "VersionGroupNote",
          "VersionComment",
          "Field",
          "SignatureComment",
          "CertificateSubject",
          "TagComment",
          "AnnotationComment",
          "Attachment"
        ]
      },
      "SimpleSearchRequest": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "searchCommand": {
            "type": "string",
            "description": "Search command for simple search",
            "nullable": true
          }
        }
      },
      "ODataValueContextOfIListOfWTemplateInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfWTemplateInfo"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfWTemplateInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WTemplateInfo"
            }
          }
        }
      },
      "WTemplateInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the template definition.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "The name of the template definition.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "The localized name of the template definition.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "The description of the template definition.",
            "nullable": true
          },
          "color": {
            "description": "The color assigned to the template definition.",
            "nullable": true,
            "oneOf": [
              {
                "$ref": "#/components/schemas/LFColor"
              }
            ]
          },
          "fieldCount": {
            "type": "integer",
            "description": "The number of fields assigned to the template.",
            "format": "int32"
          }
        }
      },
      "LFColor": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "a": {
            "type": "integer",
            "format": "byte"
          },
          "r": {
            "type": "integer",
            "format": "byte"
          },
          "g": {
            "type": "integer",
            "format": "byte"
          },
          "b": {
            "type": "integer",
            "format": "byte"
          }
        }
      },
      "ODataValueContextOfIListOfTemplateFieldInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ODataValueOfIListOfTemplateFieldInfo"
          },
          {
            "type": "object",
            "description": "A wrapper around the ODataValue with extra odata.nextLink and odata.count.",
            "additionalProperties": false,
            "properties": {
              "@odata.nextLink": {
                "type": "string",
                "description": "It contains a URL that allows retrieving the next subset of the requested collection.",
                "nullable": true
              },
              "@odata.count": {
                "type": "integer",
                "description": "It contains the count of a collection of entities or a collection of entity references.",
                "format": "int32"
              }
            }
          }
        ]
      },
      "ODataValueOfIListOfTemplateFieldInfo": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TemplateFieldInfo"
            }
          }
        }
      },
      "TemplateFieldInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WFieldInfo"
          },
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "rule": {
                "description": "A form logic rule associated with a Laserfiche template and field definition.",
                "nullable": true,
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/Rule"
                  }
                ]
              },
              "groupId": {
                "type": "integer",
                "description": "The group id of the field in the template.",
                "format": "int32"
              },
              "groupName": {
                "type": "string",
                "description": "The name of field group.",
                "nullable": true
              }
            }
          }
        ]
      },
      "Rule": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "ancestors": {
            "type": "array",
            "description": "The IDs of the parent fields in the template according to the\nform logic rule.",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "ODataValueOfDateTime": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "type": "string",
            "format": "date-time"
          }
        }
      }
    },
    "securitySchemes": {
      "Authorization": {
        "type": "http",
        "description": "Type your token into the textbox.",
        "scheme": "bearer"
      },
      "OAuth2 Authorization Code Flow": {
        "type": "oauth2",
        "description": "<p>Note: Please enter below the clientId/clientSecret of a registered web application, or the clientId of a SPA. For SPA, the clientSecret field must be left empty. The app, either a web application or SPA, must have the following uri defined as its redirect uri.</p><p>https://api.laserfiche.com/repository/swagger/oauth2-redirect.html</p>",
        "flows": {
          "authorizationCode": {
            "authorizationUrl": "https://signin.laserfiche.com/oauth/Authorize",
            "tokenUrl": "https://signin.laserfiche.com/oauth/Token",
            "scopes": {}
          }
        }
      },
      "OAuth2 Client Credentials Flow": {
        "type": "http",
        "description": "",
        "scheme": "Bearer",
        "bearerFormat": "JWT",
        "flows": {
          "clientCredentials": {
            "tokenUrl": "https://signin.laserfiche.com/oauth/Token",
            "scopes": {}
          }
        }
      }
    }
  },
  "security": [
    {
      "Authorization": []
    },
    {
      "OAuth2 Authorization Code Flow": []
    },
    {
      "OAuth2 Client Credentials Flow": []
    }
  ]
}